{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IPriceFeedOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface Aggregator {\n  function decimals() external view returns (uint8);\n  function latestAnswer() external view returns (int);\n}\n\ninterface IPriceFeedOracle {\n\n  enum AggregatorType { ETH, USD }\n\n  struct AssetInfo {\n    Aggregator aggregator;\n    AggregatorType aggregatorType;\n    uint8 decimals;\n  }\n\n  function ETH() external view returns (address);\n  function assets(address) external view returns (Aggregator, uint8);\n  function assetsMap(address) external view returns (Aggregator, AggregatorType, uint8);\n\n  function getAssetToEthRate(address asset) external view returns (uint);\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\n  function getEthForAsset(address asset, uint amount) external view returns (uint);\n\n  /* ========== ERRORS ========== */\n\n  error EmptyAssetAddresses();\n  error ArgumentLengthMismatch(uint assetAddressesLength, uint aggregatorsLength, uint typesLength, uint decimalsLength);\n  error ZeroAddress(string parameter);\n  error ZeroDecimals(address asset);\n  error IncompatibleAggregatorDecimals(address aggregator, uint8 aggregatorDecimals, uint8 expectedDecimals);\n  error UnknownAggregatorType(uint8 aggregatorType);\n  error EthUsdAggregatorNotSet();\n  error InvalidEthAggregatorType(AggregatorType actual, AggregatorType expected);\n  error UnknownAsset(address asset);\n  error NonPositiveRate(address aggregator, int rate);\n}\n"
    },
    "contracts/modules/capital/PriceFeedOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"../../interfaces/IPriceFeedOracle.sol\";\n\ncontract PriceFeedOracle is IPriceFeedOracle {\n\n  mapping(address => AssetInfo) public assetsMap;\n\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public immutable safeTracker;\n\n  constructor(\n    address[] memory _assetAddresses,\n    address[] memory _assetAggregators,\n    AggregatorType[] memory _aggregatorTypes,\n    uint8[] memory _assetDecimals,\n    address _safeTracker\n  ) {\n    if (_assetAddresses.length == 0) {\n      revert EmptyAssetAddresses();\n    }\n    if (\n      _assetAddresses.length != _assetAggregators.length ||\n      _assetAggregators.length != _aggregatorTypes.length ||\n      _aggregatorTypes.length != _assetDecimals.length\n    ) {\n      revert ArgumentLengthMismatch(\n        _assetAddresses.length,\n        _assetAggregators.length,\n        _aggregatorTypes.length,\n        _assetDecimals.length\n      );\n    }\n    if (_safeTracker == address(0)) {\n      revert ZeroAddress(\"safeTracker\");\n    }\n\n    safeTracker = _safeTracker;\n    assetsMap[_safeTracker] = AssetInfo(Aggregator(_safeTracker), AggregatorType.ETH, 18);\n\n    for (uint i = 0; i < _assetAddresses.length; i++) {\n      if (_assetAddresses[i] == address(0)) {\n        revert ZeroAddress(\"assetAddress\");\n      }\n      if (_assetAggregators[i] == address(0)) {\n        revert ZeroAddress(\"aggregator\");\n      }\n      if (_assetDecimals[i] == 0) {\n        revert ZeroDecimals(_assetAddresses[i]);\n      }\n\n      Aggregator aggregator = Aggregator(_assetAggregators[i]);\n      uint8 aggregatorDecimals = aggregator.decimals();\n\n      if (_aggregatorTypes[i] == AggregatorType.ETH && aggregatorDecimals != 18) {\n          revert IncompatibleAggregatorDecimals(_assetAggregators[i], aggregatorDecimals, 18);\n      }\n      if (_aggregatorTypes[i] == AggregatorType.USD && aggregatorDecimals != 8) {\n          revert IncompatibleAggregatorDecimals(_assetAggregators[i], aggregatorDecimals, 8);\n      }\n\n      assetsMap[_assetAddresses[i]] = AssetInfo(aggregator, _aggregatorTypes[i], _assetDecimals[i]);\n    }\n\n    // Require ETH-USD asset\n    AssetInfo memory ethAsset = assetsMap[ETH];\n    if (address(ethAsset.aggregator) == address(0)) {\n      revert EthUsdAggregatorNotSet();\n    }\n    if (ethAsset.aggregatorType != AggregatorType.USD) {\n      revert InvalidEthAggregatorType(ethAsset.aggregatorType, AggregatorType.USD);\n    }\n  }\n\n  /// @notice Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\n  /// @param assetAddress address of asset\n  /// @return price in ether\n  function getAssetToEthRate(address assetAddress) public view returns (uint) {\n    if (assetAddress == ETH || assetAddress == safeTracker) {\n      return 1 ether;\n    }\n\n    AssetInfo memory asset = assetsMap[assetAddress];\n    return _getAssetToEthRate(asset.aggregator, asset.aggregatorType);\n  }\n\n  /// @notice Returns the amount of currency that is equivalent to ethIn amount of ether.\n  /// @param assetAddress address of asset\n  /// @param ethIn amount of ether to be converted to the asset\n  /// @return asset amount\n  function getAssetForEth(address assetAddress, uint ethIn) external view returns (uint) {\n    if (assetAddress == ETH || assetAddress == safeTracker) {\n      return ethIn;\n    }\n\n    AssetInfo memory asset = assetsMap[assetAddress];\n    uint price = _getAssetToEthRate(asset.aggregator, asset.aggregatorType);\n\n    return ethIn * (10 ** uint(asset.decimals)) / price;\n  }\n\n  /// @notice Returns the amount of eth that is equivalent to a given asset and amount\n  /// @param assetAddress address of asset\n  /// @param amount amount of asset\n  /// @return amount of ether\n  function getEthForAsset(address assetAddress, uint amount) external view returns (uint) {\n    if (assetAddress == ETH || assetAddress == safeTracker) {\n      return amount;\n    }\n\n    AssetInfo memory asset = assetsMap[assetAddress];\n    uint price = _getAssetToEthRate(asset.aggregator, asset.aggregatorType);\n\n    return amount * (price) / 10 ** uint(asset.decimals);\n  }\n\n  /// @notice Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\n  /// @param aggregator The asset aggregator\n  /// @param aggregatorType The asset aggregator type (i.e ETH, USD)\n  /// @return price in ether\n  function _getAssetToEthRate(Aggregator aggregator, AggregatorType aggregatorType) internal view returns (uint) {\n    // NOTE: Current implementation relies on off-chain staleness checks, consider adding on-chain staleness check?\n    int rate = aggregator.latestAnswer();\n    if (rate <= 0) {\n      revert NonPositiveRate(address(aggregator), rate);\n    }\n\n    if (aggregatorType == AggregatorType.ETH) {\n      return uint(rate);\n    }\n\n    // AggregatorType.USD - convert the USD rate to its equivalent ETH rate using the ETH-USD exchange rate\n    AssetInfo memory ethAsset = assetsMap[ETH];\n\n    int ethUsdRate = ethAsset.aggregator.latestAnswer();\n    if (ethUsdRate <= 0) {\n      revert NonPositiveRate(ETH, ethUsdRate);\n    }\n\n    return (uint(rate) * 1e18) / uint(ethUsdRate);\n  }\n\n  /// @notice Retrieves the aggregator and decimals for a specific asset\n  /// @param assetAddress address of the asset\n  /// @return Aggregator instance and decimals of the asset\n  function assets(address assetAddress) external view returns (Aggregator, uint8) {\n    AssetInfo memory asset = assetsMap[assetAddress];\n    return (asset.aggregator, asset.decimals);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-v4/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-v4/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-v4/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/abstract/MasterAwareV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"../interfaces/INXMMaster.sol\";\nimport \"../interfaces/IMasterAwareV2.sol\";\nimport \"../interfaces/IMemberRoles.sol\";\n\nabstract contract MasterAwareV2 is IMasterAwareV2 {\n\n  INXMMaster public master;\n\n  mapping(uint => address payable) public internalContracts;\n\n  modifier onlyMember {\n    require(\n      IMemberRoles(internalContracts[uint(ID.MR)]).checkRole(\n        msg.sender,\n        uint(IMemberRoles.Role.Member)\n      ),\n      \"Caller is not a member\"\n    );\n    _;\n  }\n\n  modifier onlyAdvisoryBoard {\n    require(\n      IMemberRoles(internalContracts[uint(ID.MR)]).checkRole(\n        msg.sender,\n        uint(IMemberRoles.Role.AdvisoryBoard)\n      ),\n      \"Caller is not an advisory board member\"\n    );\n    _;\n  }\n\n  modifier onlyInternal {\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\n    _;\n  }\n\n  modifier onlyMaster {\n    if (address(master) != address(0)) {\n      require(address(master) == msg.sender, \"Not master\");\n    }\n    _;\n  }\n\n  modifier onlyGovernance {\n    require(\n      master.checkIsAuthToGoverned(msg.sender),\n      \"Caller is not authorized to govern\"\n    );\n    _;\n  }\n\n  modifier onlyEmergencyAdmin {\n    require(\n      msg.sender == master.emergencyAdmin(),\n      \"Caller is not emergency admin\"\n    );\n    _;\n  }\n\n  modifier whenPaused {\n    require(master.isPause(), \"System is not paused\");\n    _;\n  }\n\n  modifier whenNotPaused {\n    require(!master.isPause(), \"System is paused\");\n    _;\n  }\n\n  function getInternalContractAddress(ID id) internal view returns (address payable) {\n    return internalContracts[uint(id)];\n  }\n\n  function changeMasterAddress(address masterAddress) public onlyMaster {\n    master = INXMMaster(masterAddress);\n  }\n\n}\n"
    },
    "contracts/interfaces/IAssessment.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IAssessment {\n\n  /* ========== DATA STRUCTURES ========== */\n\n  enum UintParams {\n    minVotingPeriodInDays,\n    stakeLockupPeriodInDays,\n    payoutCooldownInDays,\n    silentEndingPeriodInDays\n  }\n\n  struct Configuration {\n    // The minimum number of days the users can vote on polls\n    uint8 minVotingPeriodInDays;\n\n    // Number of days the users must wait from their last vote to withdraw their stake.\n    uint8 stakeLockupPeriodInDays;\n\n    // Number of days the users must wait after a poll closes to redeem payouts.\n    uint8 payoutCooldownInDays;\n\n    // Number of days representing the silence period. It is used to extend a poll's end date when\n    // a vote is cast during the silence period before the end date.\n    uint8 silentEndingPeriodInDays;\n  }\n\n  struct Stake {\n    uint96 amount;\n    uint104 rewardsWithdrawableFromIndex;\n    uint16 fraudCount;\n    /*uint32 unused,*/\n  }\n\n  // Holds data for a vote belonging to an assessor.\n  //\n  // The structure is used to keep track of user's votes. Each vote is used to determine\n  // a user's share of rewards or to create a fraud resolution which excludes fraudulent votes\n  // from the initial poll.\n  struct Vote {\n    // Identifier of the claim or incident\n    uint80 assessmentId;\n\n    // If the assessor votes to accept the event it's true otherwise it's false\n    bool accepted;\n\n    // Date and time when the vote was cast\n    uint32 timestamp;\n\n    // How many tokens were staked when the vote was cast\n    uint96 stakedAmount;\n  }\n\n  // Holds poll results for an assessment.\n  //\n  // The structure is used to keep track of all votes on a given assessment such as how many NXM were\n  // used to cast accept and deny votes as well as when the poll started and when it ends.\n  struct Poll {\n    // The amount of NXM from accept votes\n    uint96 accepted;\n\n    // The amount of NXM from deny votes\n    uint96 denied;\n\n    // Timestamp of when the poll started.\n    uint32 start;\n\n    // Timestamp of when the poll ends.\n    uint32 end;\n  }\n\n  // Holds data for an assessment belonging to an assessable event (individual claims, yield token\n  // incidents etc.).\n  //\n  // The structure is used to keep track of the total reward that should be distributed to\n  // assessors, the assessment deposit the claimants made to start the assessment, and the poll\n  // coresponding to this assessment.\n  struct Assessment {\n    // See Poll struct\n    Poll poll;\n\n    // The amount of NXM representing the assessment reward which is split among those who voted.\n    uint128 totalRewardInNXM;\n\n    // An amount of ETH which is sent back to the claimant when the poll result is positive,\n    // otherwise it is kep it the pool to back the assessment rewards. This allows claimants to\n    // open an unlimited amount of claims and prevents unbacked NXM to be minted through the\n    // assessment process.\n    uint128 assessmentDepositInETH;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function getAssessmentsCount() external view returns (uint);\n\n  function assessments(uint id) external view\n  returns (Poll memory poll, uint128 totalReward, uint128 assessmentDeposit);\n\n  function getPoll(uint assessmentId) external view returns (Poll memory);\n\n  function getRewards(address user) external view returns (\n    uint totalPendingAmount,\n    uint withdrawableAmount,\n    uint withdrawableUntilIndex\n  );\n\n  function getVoteCountOfAssessor(address assessor) external view returns (uint);\n\n  function votesOf(address user, uint voteIndex) external view\n  returns (uint80 assessmentId, bool accepted, uint32 timestamp, uint96 stakedAmount);\n\n  function stakeOf(address user) external view\n  returns (uint96 amount, uint104 rewardsWithdrawableFromIndex, uint16 fraudCount);\n\n  function config() external view returns (\n    uint8 minVotingPeriodInDays,\n    uint8 stakeLockupPeriodInDays,\n    uint8 payoutCooldownInDays,\n    uint8 silentEndingPeriodInDays\n  );\n\n  function hasAlreadyVotedOn(address voter, uint assessmentId) external view returns (bool);\n\n\n  /* === MUTATIVE FUNCTIONS ==== */\n\n  function stake(uint96 amount) external;\n\n  function unstake(uint96 amount, address to) external;\n\n  function unstakeAllFor(address staker) external;\n\n  function withdrawRewards(\n    address user,\n    uint104 batchSize\n  ) external returns (uint withdrawn, uint withdrawnUntilIndex);\n\n  function withdrawRewardsTo(\n    address destination,\n    uint104 batchSize\n  ) external returns (uint withdrawn, uint withdrawnUntilIndex);\n\n  function startAssessment(uint totalReward, uint assessmentDeposit) external\n  returns (uint);\n\n  function castVotes(\n    uint[] calldata assessmentIds,\n    bool[] calldata votes,\n    string[] calldata ipfsAssessmentDataHashes,\n    uint96 stakeIncrease\n  ) external;\n\n  function submitFraud(bytes32 root) external;\n\n  function processFraud(\n    uint256 rootIndex,\n    bytes32[] calldata proof,\n    address assessor,\n    uint256 lastFraudulentVoteIndex,\n    uint96 burnAmount,\n    uint16 fraudCount,\n    uint256 voteBatchSize\n  ) external;\n\n  function updateUintParameters(UintParams[] calldata paramNames, uint[] calldata values) external;\n\n  /* ========== EVENTS ========== */\n\n  event StakeDeposited(address user, uint104 amount);\n  event StakeWithdrawn(address indexed user, address to, uint96 amount);\n  event VoteCast(address indexed user, uint256 assessmentId, uint96 stakedAmount, bool accepted, string ipfsAssessmentDataHash);\n  event RewardWithdrawn(address user, address to, uint256 amount);\n  event FraudProcessed(uint assessmentId, address assessor, Poll poll);\n  event FraudSubmitted(bytes32 root);\n\n  /* ========== ERRORS ========== */\n\n  error InvalidAmount(uint maxUnstakeAmount);\n  error StakeLockedForAssessment(uint lockupExpiry);\n  error StakeLockedForGovernance(uint lockupExpiry);\n  error NotMember(address nonMember);\n  error NoWithdrawableRewards();\n  error InvalidMerkleProof();\n  error OnlyTokenController();\n\n  // Votes\n  error AssessmentIdsVotesLengthMismatch();\n  error AssessmentIdsIpfsLengthMismatch();\n  error AlreadyVoted();\n  error StakeRequired();\n  error VotingClosed();\n  error AcceptVoteRequired();\n}\n"
    },
    "contracts/interfaces/ICompleteStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IStakingPoolFactory.sol\";\n\n/**\n * @dev IStakingPoolFactory is missing the changeOperator() and operator() functions.\n * @dev Any change to the original interface will affect staking pool addresses\n * @dev This interface is created to add the missing functions so it can be used in other contracts.\n */\ninterface ICompleteStakingPoolFactory is IStakingPoolFactory {\n\n  function operator() external view returns (address);\n\n  function changeOperator(address newOperator) external;\n}\n"
    },
    "contracts/interfaces/ICover.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./ICoverNFT.sol\";\nimport \"./IStakingNFT.sol\";\nimport \"./IStakingPool.sol\";\nimport \"./ICompleteStakingPoolFactory.sol\";\n\n/* io structs */\n\nenum ClaimMethod {\n  IndividualClaims,\n  YieldTokenIncidents\n}\n\nstruct PoolAllocationRequest {\n  uint40 poolId;\n  bool skip;\n  uint coverAmountInAsset;\n}\n\nstruct BuyCoverParams {\n  uint coverId;\n  address owner;\n  uint24 productId;\n  uint8 coverAsset;\n  uint96 amount;\n  uint32 period;\n  uint maxPremiumInAsset;\n  uint8 paymentAsset;\n  uint16 commissionRatio;\n  address commissionDestination;\n  string ipfsData;\n}\n\n/* storage structs */\n\nstruct PoolAllocation {\n  uint40 poolId;\n  uint96 coverAmountInNXM;\n  uint96 premiumInNXM;\n  uint24 allocationId;\n}\n\nstruct CoverData {\n  uint24 productId;\n  uint8 coverAsset;\n  uint96 amountPaidOut;\n}\n\nstruct CoverSegment {\n  uint96 amount;\n  uint32 start;\n  uint32 period; // seconds\n  uint32 gracePeriod; // seconds\n  uint24 globalRewardsRatio;\n  uint24 globalCapacityRatio;\n}\n\ninterface ICover {\n\n  /* ========== DATA STRUCTURES ========== */\n\n  /* internal structs */\n\n  struct RequestAllocationVariables {\n    uint previousPoolAllocationsLength;\n    uint previousPremiumInNXM;\n    uint refund;\n    uint coverAmountInNXM;\n  }\n\n  /* storage structs */\n\n  struct ActiveCover {\n    // Global active cover amount per asset.\n    uint192 totalActiveCoverInAsset;\n    // The last time activeCoverExpirationBuckets was updated\n    uint64 lastBucketUpdateId;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function coverData(uint coverId) external view returns (CoverData memory);\n\n  function coverDataCount() external view returns (uint);\n\n  function coverSegmentsCount(uint coverId) external view returns (uint);\n\n  function coverSegments(uint coverId) external view returns (CoverSegment[] memory);\n\n  function coverSegmentWithRemainingAmount(\n    uint coverId,\n    uint segmentId\n  ) external view returns (CoverSegment memory);\n\n  function recalculateActiveCoverInAsset(uint coverAsset) external;\n\n  function totalActiveCoverInAsset(uint coverAsset) external view returns (uint);\n\n  function getGlobalCapacityRatio() external view returns (uint);\n\n  function getGlobalRewardsRatio() external view returns (uint);\n\n  function getDefaultMinPriceRatio() external pure returns (uint);\n\n  function getGlobalCapacityAndPriceRatios() external view returns (\n    uint _globalCapacityRatio,\n    uint _defaultMinPriceRatio\n  );\n\n  function DEFAULT_MIN_PRICE_RATIO() external view returns (uint);\n\n  /* === MUTATIVE FUNCTIONS ==== */\n\n  function buyCover(\n    BuyCoverParams calldata params,\n    PoolAllocationRequest[] calldata coverChunkRequests\n  ) external payable returns (uint coverId);\n\n  function burnStake(\n    uint coverId,\n    uint segmentId,\n    uint amount\n  ) external returns (address coverOwner);\n\n  function coverNFT() external returns (ICoverNFT);\n\n  function stakingNFT() external returns (IStakingNFT);\n\n  function stakingPoolFactory() external returns (ICompleteStakingPoolFactory);\n\n  /* ========== EVENTS ========== */\n\n  event CoverEdited(uint indexed coverId, uint indexed productId, uint indexed segmentId, address buyer, string ipfsMetadata);\n\n  // Auth\n  error OnlyOwnerOrApproved();\n\n  // Cover details\n  error CoverPeriodTooShort();\n  error CoverPeriodTooLong();\n  error CoverOutsideOfTheGracePeriod();\n  error CoverAmountIsZero();\n\n  // Products\n  error ProductNotFound();\n  error ProductDeprecated();\n  error UnexpectedProductId();\n\n  // Cover and payment assets\n  error CoverAssetNotSupported();\n  error InvalidPaymentAsset();\n  error UnexpectedCoverAsset();\n  error UnexpectedEthSent();\n  error EditNotSupported();\n\n  // Price & Commission\n  error PriceExceedsMaxPremiumInAsset();\n  error CommissionRateTooHigh();\n\n  // ETH transfers\n  error InsufficientEthSent();\n  error SendingEthToPoolFailed();\n  error SendingEthToCommissionDestinationFailed();\n  error ReturningEthRemainderToSenderFailed();\n\n  // Misc\n  error ExpiredCoversCannotBeEdited();\n  error CoverNotYetExpired(uint coverId);\n  error InsufficientCoverAmountAllocated();\n  error UnexpectedPoolId();\n\n  // TODO: remove me after the rewards update\n  error OnlySwapOperator();\n}\n"
    },
    "contracts/interfaces/ICoverNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts-v4/token/ERC721/IERC721.sol\";\n\ninterface ICoverNFT is IERC721 {\n\n  function isApprovedOrOwner(address spender, uint tokenId) external returns (bool);\n\n  function mint(address to) external returns (uint tokenId);\n\n  function changeOperator(address newOperator) external;\n\n  function changeNFTDescriptor(address newNFTDescriptor) external;\n\n  function totalSupply() external view returns (uint);\n\n  function name() external view returns (string memory);\n\n  error NotOperator();\n  error NotMinted();\n  error WrongFrom();\n  error InvalidRecipient();\n  error InvalidNewOperatorAddress();\n  error InvalidNewNFTDescriptorAddress();\n  error NotAuthorized();\n  error UnsafeRecipient();\n  error AlreadyMinted();\n\n}\n"
    },
    "contracts/interfaces/ICoverProducts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./ICover.sol\";\n\n/* io structs */\n\nstruct ProductInitializationParams {\n  uint productId;\n  uint8 weight;\n  uint96 initialPrice;\n  uint96 targetPrice;\n}\n\n/* storage structs */\n\nstruct Product {\n  uint16 productType;\n  uint16 minPrice;\n  // leftover memory gap from the previously used address field yieldTokenAddress\n  uint144 __gap;\n  // cover assets bitmap. each bit represents whether the asset with\n  // the index of that bit is enabled as a cover asset for this product\n  uint32 coverAssets;\n  uint16 initialPriceRatio;\n  uint16 capacityReductionRatio;\n  bool isDeprecated;\n  bool useFixedPrice;\n}\n\nstruct ProductType {\n  uint8 claimMethod;\n  uint32 gracePeriod;\n}\n\ninterface ICoverProducts {\n\n  /* storage structs */\n\n  struct Metadata {\n    string ipfsHash;\n    uint timestamp;\n  }\n\n  /* io structs */\n\n  struct ProductParam {\n    string productName;\n    uint productId;\n    string ipfsMetadata;\n    Product product;\n    uint[] allowedPools;\n  }\n\n  struct ProductTypeParam {\n    string productTypeName;\n    uint productTypeId;\n    string ipfsMetadata;\n    ProductType productType;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function getProductType(uint productTypeId) external view returns (ProductType memory);\n\n  function getProductTypeName(uint productTypeId) external view returns (string memory);\n\n  function getProductTypeCount() external view returns (uint);\n\n  function getProductTypes() external view returns (ProductType[] memory);\n\n  function getProduct(uint productId) external view returns (Product memory);\n\n  function getProductName(uint productTypeId) external view returns (string memory);\n\n  function getProductCount() external view returns (uint);\n\n  function getProducts() external view returns (Product[] memory);\n\n  // add grace period function?\n  function getProductWithType(uint productId) external view returns (Product memory, ProductType memory);\n\n  function getLatestProductMetadata(uint productId) external view returns (Metadata memory);\n\n  function getLatestProductTypeMetadata(uint productTypeId) external view returns (Metadata memory);\n\n  function getProductMetadata(uint productId) external view returns (Metadata[] memory);\n\n  function getProductTypeMetadata(uint productTypeId) external view returns (Metadata[] memory);\n\n  function getAllowedPools(uint productId) external view returns (uint[] memory _allowedPools);\n\n  function getAllowedPoolsCount(uint productId) external view returns (uint);\n\n  function isPoolAllowed(uint productId, uint poolId) external view returns (bool);\n\n  function requirePoolIsAllowed(uint[] calldata productIds, uint poolId) external view;\n\n  function getCapacityReductionRatios(uint[] calldata productIds) external view returns (uint[] memory);\n\n  function getInitialPrices(uint[] calldata productIds) external view returns (uint[] memory);\n\n  function getMinPrices(uint[] calldata productIds) external view returns (uint[] memory);\n\n  function prepareStakingProductsParams(\n    ProductInitializationParams[] calldata params\n  ) external returns (\n    ProductInitializationParams[] memory validatedParams\n  );\n\n  /* === MUTATIVE FUNCTIONS ==== */\n\n  function setProductTypes(ProductTypeParam[] calldata productTypes) external;\n\n  function setProducts(ProductParam[] calldata params) external;\n\n  /* ========== EVENTS ========== */\n\n  event ProductSet(uint id);\n  event ProductTypeSet(uint id);\n\n  // Products and product types\n  error ProductNotFound();\n  error ProductTypeNotFound();\n  error ProductDeprecated();\n  error PoolNotAllowedForThisProduct(uint productId);\n  error StakingPoolDoesNotExist();\n  error MismatchedArrayLengths();\n  error MetadataRequired();\n\n  // Misc\n  error UnsupportedCoverAssets();\n  error InitialPriceRatioBelowMinPriceRatio();\n  error InitialPriceRatioAbove100Percent();\n  error CapacityReductionRatioAbove100Percent();\n\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IERC20Detailed {\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function decimals() external view returns (uint8);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IIndividualClaims.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts-v4/token/ERC721/IERC721Receiver.sol\";\n\ninterface IIndividualClaims {\n\n  enum ClaimStatus { PENDING, ACCEPTED, DENIED }\n\n  enum PayoutStatus { PENDING, COMPLETE, UNCLAIMED, DENIED }\n\n  enum UintParams {\n    payoutRedemptionPeriodInDays,\n    minAssessmentDepositRatio,\n    maxRewardInNXMWad,\n    rewardRatio\n  }\n\n  struct Configuration {\n    // Number of days in which payouts can be redeemed\n    uint8 payoutRedemptionPeriodInDays;\n\n    // Ratio out of 1 ETH, used to calculate a flat ETH deposit required for claim submission.\n    // If the claim is accepted, the user will receive the deposit back when the payout is redeemed.\n    // (0-10000 bps i.e. double decimal precision)\n    uint16 minAssessmentDepositRatio;\n\n    // An amount of NXM representing the maximum reward amount given for any claim assessment.\n    uint16 maxRewardInNXMWad;\n\n    // Ratio used to calculate assessment rewards. (0-10000 i.e. double decimal precision).\n    uint16 rewardRatio;\n  }\n\n  // Holds the requested amount, NXM price, submission fee and other relevant details\n  // such as parts of the corresponding cover details and the payout status.\n  //\n  // This structure has snapshots of claim-time states that are considered moving targets\n  // but also parts of cover details that reduce the need of external calls. Everything is fitted\n  // in a single word that contains:\n  struct Claim {\n    // The index of the assessment, stored in Assessment.sol\n    uint80 assessmentId;\n\n    // The identifier of the cover on which this claim is submitted\n    uint32 coverId;\n\n    // The index of the cover segment on which this claim is submitted\n    uint16 segmentId;\n\n    // Amount requested as part of this claim up to the total cover amount\n    uint96 amount;\n\n    // The index of of the asset address stored at addressOfAsset which is expected at payout.\n    uint8 coverAsset;\n\n    // True if the payout is already redeemed. Prevents further payouts on the claim if it is\n    // accepted.\n    bool payoutRedeemed;\n  }\n\n  struct ClaimSubmission {\n    // The index of the claim, stored in Claims.sol\n    uint80 claimId;\n    // True when a previous submission exists\n    bool exists;\n  }\n\n  // Claim structure but in a human-friendly format.\n  //\n  // Contains aggregated values that give an overall view about the claim and other relevant\n  // pieces of information such as cover period, asset symbol etc. This structure is not used in\n  // any storage variables.\n  struct ClaimDisplay {\n    uint id;\n    uint productId;\n    uint coverId;\n    uint assessmentId;\n    uint amount;\n    string assetSymbol;\n    uint assetIndex;\n    uint coverStart;\n    uint coverEnd;\n    uint pollStart;\n    uint pollEnd;\n    uint claimStatus;\n    uint payoutStatus;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function claims(uint id) external view returns (\n    uint80 assessmentId,\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 amount,\n    uint8 coverAsset,\n    bool payoutRedeemed\n  );\n\n  function config() external view returns (\n    uint8 payoutRedemptionPeriodInDays,\n    uint16 minAssessmentDepositRatio,\n    uint16 maxRewardRatio,\n    uint16 rewardRatio\n  );\n\n  function getClaimsCount() external view returns (uint);\n\n  /* === MUTATIVE FUNCTIONS ==== */\n\n  function submitClaim(\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 requestedAmount,\n    string calldata ipfsMetadata\n  ) external payable returns (Claim memory);\n\n  function submitClaimFor(\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 requestedAmount,\n    string calldata ipfsMetadata,\n    address owner\n  ) external payable returns (Claim memory);\n\n  function redeemClaimPayout(uint104 id) external;\n\n  function updateUintParameters(UintParams[] calldata paramNames, uint[] calldata values) external;\n\n  /* ========== EVENTS ========== */\n\n  event ClaimSubmitted(address indexed user, uint claimId, uint indexed coverId, uint productId);\n  event MetadataSubmitted(uint indexed claimId, string ipfsMetadata);\n  event ClaimPayoutRedeemed(address indexed user, uint amount, uint claimId, uint coverId);\n\n}\n"
    },
    "contracts/interfaces/IMasterAwareV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IMasterAwareV2 {\n\n  // TODO: if you update this enum, update lib/constants.js as well\n  enum ID {\n    TC, // TokenController.sol\n    P1, // Pool.sol\n    MR, // MemberRoles.sol\n    MC, // MCR.sol\n    CO, // Cover.sol\n    SP, // StakingProducts.sol\n    PS, // LegacyPooledStaking.sol\n    GV, // Governance.sol\n    UNUSED_GW, // LegacyGateway.sol - removed\n    UNUSED_CL, // CoverMigrator.sol - removed\n    AS, // Assessment.sol\n    CI, // IndividualClaims.sol - Claims for Individuals\n    UNUSED_CG, // YieldTokenIncidents.sol - Claims for Groups -- removed\n    RA, // Ramm.sol\n    ST,  // SafeTracker.sol\n    CP  // CoverProducts.sol\n  }\n\n  function changeMasterAddress(address masterAddress) external;\n\n  function changeDependentContractAddress() external;\n\n  function internalContracts(uint) external view returns (address payable);\n}\n"
    },
    "contracts/interfaces/IMemberRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IMemberRoles {\n\n  enum Role {Unassigned, AdvisoryBoard, Member, Owner}\n\n  function join(address _userAddress, uint nonce, bytes calldata signature) external payable;\n\n  function switchMembership(address _newAddress) external;\n\n  function switchMembershipAndAssets(\n    address newAddress,\n    uint[] calldata coverIds,\n    uint[] calldata stakingTokenIds\n  ) external;\n\n  function switchMembershipOf(address member, address _newAddress) external;\n\n  function totalRoles() external view returns (uint256);\n\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\n\n  function setKycAuthAddress(address _add) external;\n\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\n\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\n\n  function authorized(uint _memberRoleId) external view returns (address);\n\n  function roles(address _memberAddress) external view returns (uint[] memory);\n\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\n\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\n\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\n\n  function membersLength(uint _memberRoleId) external view returns (uint);\n\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n\n  event MemberJoined(address indexed newMember, uint indexed nonce);\n\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\n  \n  event MembershipWithdrawn(address indexed member, uint timestamp);\n}\n"
    },
    "contracts/interfaces/INXMMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface INXMMaster {\n\n  function tokenAddress() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function emergencyAdmin() external view returns (address);\n\n  function masterInitialized() external view returns (bool);\n\n  function isInternal(address _add) external view returns (bool);\n\n  function isPause() external view returns (bool check);\n\n  function isMember(address _add) external view returns (bool);\n\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\n\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\n\n  function contractAddresses(bytes2 code) external view returns (address payable);\n\n  function upgradeMultipleContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses\n  ) external;\n\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\n\n  function addNewInternalContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses,\n    uint[] calldata _types\n  ) external;\n\n  function updateOwnerParameters(bytes8 code, address payable val) external;\n}\n"
    },
    "contracts/interfaces/INXMToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface INXMToken {\n\n  function burn(uint256 amount) external returns (bool);\n\n  function burnFrom(address from, uint256 value) external returns (bool);\n\n  function operatorTransfer(address from, uint256 value) external returns (bool);\n\n  function mint(address account, uint256 amount) external;\n\n  function isLockedForMV(address member) external view returns (uint);\n\n  function whiteListed(address member) external view returns (bool);\n\n  function addToWhiteList(address _member) external returns (bool);\n\n  function removeFromWhiteList(address _member) external returns (bool);\n\n  function changeOperator(address _newOperator) external returns (bool);\n\n  function lockForMemberVote(address _of, uint _days) external;\n\n  /**\n * @dev Returns the amount of tokens in existence.\n */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPriceFeedOracle.sol\";\n\nstruct SwapDetails {\n  uint104 minAmount;\n  uint104 maxAmount;\n  uint32 lastSwapTime;\n  // 2 decimals of precision. 0.01% -> 0.0001 -> 1e14\n  uint16 maxSlippageRatio;\n}\n\nstruct Asset {\n  address assetAddress;\n  bool isCoverAsset;\n  bool isAbandoned;\n}\n\ninterface IPool {\n\n  error RevertedWithoutReason(uint index);\n  error AssetNotFound();\n  error UnknownParameter();\n  error OrderInProgress();\n\n  function swapOperator() external view returns (address);\n\n  function getAsset(uint assetId) external view returns (Asset memory);\n\n  function getAssets() external view returns (Asset[] memory);\n\n  function transferAssetToSwapOperator(address asset, uint amount) external;\n\n  function setSwapDetailsLastSwapTime(address asset, uint32 lastSwapTime) external;\n\n  function getAssetSwapDetails(address assetAddress) external view returns (SwapDetails memory);\n\n  function sendPayout(uint assetIndex, address payable payoutAddress, uint amount, uint ethDepositAmount) external;\n\n  function sendEth(address payoutAddress, uint amount) external;\n\n  function upgradeCapitalPool(address payable newPoolAddress) external;\n\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\n\n  function getPoolValueInEth() external view returns (uint);\n\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\n\n  function getInternalTokenPriceInAsset(uint assetId) external view returns (uint tokenPrice);\n\n  function getInternalTokenPriceInAssetAndUpdateTwap(uint assetId) external returns (uint tokenPrice);\n\n  function getTokenPrice() external view returns (uint tokenPrice);\n\n  function getMCRRatio() external view returns (uint);\n\n  function setSwapAssetAmount(address assetAddress, uint value) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeedOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface Aggregator {\n  function decimals() external view returns (uint8);\n  function latestAnswer() external view returns (int);\n}\n\ninterface IPriceFeedOracle {\n\n  enum AggregatorType { ETH, USD }\n\n  struct AssetInfo {\n    Aggregator aggregator;\n    AggregatorType aggregatorType;\n    uint8 decimals;\n  }\n\n  function ETH() external view returns (address);\n  function assets(address) external view returns (Aggregator, uint8);\n  function assetsMap(address) external view returns (Aggregator, AggregatorType, uint8);\n\n  function getAssetToEthRate(address asset) external view returns (uint);\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\n  function getEthForAsset(address asset, uint amount) external view returns (uint);\n\n  /* ========== ERRORS ========== */\n\n  error EmptyAssetAddresses();\n  error ArgumentLengthMismatch(uint assetAddressesLength, uint aggregatorsLength, uint typesLength, uint decimalsLength);\n  error ZeroAddress(string parameter);\n  error ZeroDecimals(address asset);\n  error IncompatibleAggregatorDecimals(address aggregator, uint8 aggregatorDecimals, uint8 expectedDecimals);\n  error UnknownAggregatorType(uint8 aggregatorType);\n  error EthUsdAggregatorNotSet();\n  error InvalidEthAggregatorType(AggregatorType actual, AggregatorType expected);\n  error UnknownAsset(address asset);\n  error NonPositiveRate(address aggregator, int rate);\n}\n"
    },
    "contracts/interfaces/IRamm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPool.sol\";\nimport \"./INXMToken.sol\";\nimport \"./ITokenController.sol\";\n\ninterface IRamm {\n\n  // storage structs\n\n  struct Slot0 {\n    uint128 nxmReserveA;\n    uint128 nxmReserveB;\n  }\n\n  struct Slot1 {\n    uint128 ethReserve;\n    uint88 budget;\n    uint32 updatedAt;\n    bool swapPaused; // emergency pause\n  }\n\n  struct Observation {\n    uint32 timestamp;\n    uint112 priceCumulativeAbove;\n    uint112 priceCumulativeBelow;\n  }\n\n  // memory structs\n\n  struct State {\n    uint nxmA;\n    uint nxmB;\n    uint eth;\n    uint budget;\n    uint ratchetSpeedB;\n    uint timestamp;\n  }\n\n  struct Context {\n    uint capital;\n    uint supply;\n    uint mcr;\n  }\n\n  struct CumulativePriceCalculationProps {\n    uint previousEthReserve;\n    uint currentEthReserve;\n    uint previousNxmA;\n    uint currentNxmA;\n    uint previousNxmB;\n    uint currentNxmB;\n    uint previousTimestamp;\n    uint observationTimestamp;\n  }\n\n  struct CumulativePriceCalculationTimes {\n    uint secondsUntilBVAbove;\n    uint secondsUntilBVBelow;\n    uint timeElapsed;\n    uint bvTimeBelow;\n    uint bvTimeAbove;\n    uint ratchetTimeAbove;\n    uint ratchetTimeBelow;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function getReserves() external view returns (\n    uint ethReserve,\n    uint nxmA,\n    uint nxmB,\n    uint remainingBudget\n  );\n\n  function getSpotPrices() external view returns (uint spotPriceA, uint spotPriceB);\n\n  function getBookValue() external view returns (uint bookValue);\n\n  function getInternalPrice() external view returns (uint internalPrice);\n\n  /* ==== MUTATIVE FUNCTIONS ==== */\n\n  function updateTwap() external;\n\n  function getInternalPriceAndUpdateTwap() external returns (uint internalPrice);\n\n  function swap(uint nxmIn, uint minAmountOut, uint deadline) external payable returns (uint amountOut);\n\n  function removeBudget() external;\n\n  function setEmergencySwapPause(bool _swapPaused) external;\n\n  /* ========== EVENTS AND ERRORS ========== */\n\n  event EthSwappedForNxm(address indexed member, uint ethIn, uint nxmOut);\n  event NxmSwappedForEth(address indexed member, uint nxmIn, uint ethOut);\n  event ObservationUpdated(uint32 timestamp, uint112 priceCumulativeAbove, uint112 priceCumulativeBelow);\n  event BudgetRemoved();\n  event SwapPauseConfigured(bool paused);\n  event EthInjected(uint value);\n  event EthExtracted(uint value);\n\n  // Pause\n  error SystemPaused();\n  error SwapPaused();\n\n  // Input\n  error OneInputOnly();\n  error OneInputRequired();\n\n  // Expiry\n  error SwapExpired(uint deadline, uint blockTimestamp);\n\n  // Insufficient amount out\n  error InsufficientAmountOut(uint amountOut, uint minAmountOut);\n\n  // Buffer Zone\n  error NoSwapsInBufferZone();\n\n  // ETH Transfer\n  error EthTransferFailed();\n\n  // Circuit breakers\n  error EthCircuitBreakerHit();\n  error NxmCircuitBreakerHit();\n}\n"
    },
    "contracts/interfaces/IStakingNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts-v4/token/ERC721/IERC721.sol\";\n\ninterface IStakingNFT is IERC721 {\n\n  function isApprovedOrOwner(address spender, uint tokenId) external returns (bool);\n\n  function mint(uint poolId, address to) external returns (uint tokenId);\n\n  function changeOperator(address newOperator) external;\n\n  function changeNFTDescriptor(address newNFTDescriptor) external;\n\n  function totalSupply() external returns (uint);\n\n  function tokenInfo(uint tokenId) external view returns (uint poolId, address owner);\n\n  function stakingPoolOf(uint tokenId) external view returns (uint poolId);\n\n  function stakingPoolFactory() external view returns (address);\n\n  function name() external view returns (string memory);\n\n  error NotOperator();\n  error NotMinted();\n  error WrongFrom();\n  error InvalidRecipient();\n  error InvalidNewOperatorAddress();\n  error InvalidNewNFTDescriptorAddress();\n  error NotAuthorized();\n  error UnsafeRecipient();\n  error AlreadyMinted();\n  error NotStakingPool();\n\n}\n"
    },
    "contracts/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\n/* structs for io */\n\nstruct AllocationRequest {\n  uint productId;\n  uint coverId;\n  uint allocationId;\n  uint period;\n  uint gracePeriod;\n  bool useFixedPrice;\n  uint previousStart;\n  uint previousExpiration;\n  uint previousRewardsRatio;\n  uint globalCapacityRatio;\n  uint capacityReductionRatio;\n  uint rewardRatio;\n  uint productMinPrice;\n}\n\nstruct BurnStakeParams {\n  uint allocationId;\n  uint productId;\n  uint start;\n  uint period;\n  uint deallocationAmount;\n}\n\ninterface IStakingPool {\n\n  /* structs for storage */\n\n  // stakers are grouped in tranches based on the timelock expiration\n  // tranche index is calculated based on the expiration date\n  // the initial proposal is to have 4 tranches per year (1 tranche per quarter)\n  struct Tranche {\n    uint128 stakeShares;\n    uint128 rewardsShares;\n  }\n\n  struct ExpiredTranche {\n    uint96 accNxmPerRewardShareAtExpiry;\n    uint96 stakeAmountAtExpiry; // nxm total supply is 6.7e24 and uint96.max is 7.9e28\n    uint128 stakeSharesSupplyAtExpiry;\n  }\n\n  struct Deposit {\n    uint96 lastAccNxmPerRewardShare;\n    uint96 pendingRewards;\n    uint128 stakeShares;\n    uint128 rewardsShares;\n  }\n\n  struct WithdrawTrancheContext {\n    uint _firstActiveTrancheId;\n    uint _accNxmPerRewardsShare;\n    uint managerLockedInGovernanceUntil;\n    bool withdrawStake;\n    bool withdrawRewards;\n    address destination;\n}\n\n  function initialize(\n    bool isPrivatePool,\n    uint initialPoolFee,\n    uint maxPoolFee,\n    uint _poolId\n  ) external;\n\n  function processExpirations(bool updateUntilCurrentTimestamp) external;\n\n  function requestAllocation(\n    uint amount,\n    uint previousPremium,\n    AllocationRequest calldata request\n  ) external returns (uint premium, uint allocationId);\n\n  function burnStake(uint amount, BurnStakeParams calldata params) external;\n\n  function depositTo(\n    uint amount,\n    uint trancheId,\n    uint requestTokenId,\n    address destination\n  ) external returns (uint tokenId);\n\n  function withdraw(\n    uint tokenId,\n    bool withdrawStake,\n    bool withdrawRewards,\n    uint[] memory trancheIds\n  ) external returns (uint withdrawnStake, uint withdrawnRewards);\n\n  function isPrivatePool() external view returns (bool);\n\n  function isHalted() external view returns (bool);\n\n  function manager() external view returns (address);\n\n  function getPoolId() external view returns (uint);\n\n  function getPoolFee() external view returns (uint);\n\n  function getMaxPoolFee() external view returns (uint);\n\n  function getActiveStake() external view returns (uint);\n\n  function getStakeSharesSupply() external view returns (uint);\n\n  function getRewardsSharesSupply() external view returns (uint);\n\n  function getRewardPerSecond() external view returns (uint);\n\n  function getAccNxmPerRewardsShare() external view returns (uint);\n\n  function getLastAccNxmUpdate() external view returns (uint);\n\n  function getFirstActiveTrancheId() external view returns (uint);\n\n  function getFirstActiveBucketId() external view returns (uint);\n\n  function getNextAllocationId() external view returns (uint);\n\n  function getDeposit(uint tokenId, uint trancheId) external view returns (\n    uint lastAccNxmPerRewardShare,\n    uint pendingRewards,\n    uint stakeShares,\n    uint rewardsShares\n  );\n\n  function getTranche(uint trancheId) external view returns (\n    uint stakeShares,\n    uint rewardsShares\n  );\n\n  function getExpiredTranche(uint trancheId) external view returns (\n    uint accNxmPerRewardShareAtExpiry,\n    uint stakeAmountAtExpiry,\n    uint stakeShareSupplyAtExpiry\n  );\n\n  function setPoolFee(uint newFee) external;\n\n  function setPoolPrivacy(bool isPrivatePool) external;\n\n  function getActiveAllocations(\n    uint productId\n  ) external view returns (uint[] memory trancheAllocations);\n\n  function getTrancheCapacities(\n    uint productId,\n    uint firstTrancheId,\n    uint trancheCount,\n    uint capacityRatio,\n    uint reductionRatio\n  ) external view returns (uint[] memory trancheCapacities);\n\n  /* ========== EVENTS ========== */\n\n  event StakeDeposited(address indexed user, uint256 amount, uint256 trancheId, uint256 tokenId);\n\n  event DepositExtended(address indexed user, uint256 tokenId, uint256 initialTrancheId, uint256 newTrancheId, uint256 topUpAmount);\n\n  event PoolPrivacyChanged(address indexed manager, bool isPrivate);\n\n  event PoolFeeChanged(address indexed manager, uint newFee);\n\n  event Withdraw(address indexed user, uint indexed tokenId, uint tranche, uint amountStakeWithdrawn, uint amountRewardsWithdrawn);\n\n  event StakeBurned(uint amount);\n\n  event Deallocated(uint productId);\n\n  event BucketExpired(uint bucketId);\n\n  event TrancheExpired(uint trancheId);\n\n  // Auth\n  error OnlyCoverContract();\n  error OnlyStakingProductsContract();\n  error OnlyManager();\n  error PrivatePool();\n  error SystemPaused();\n  error PoolHalted();\n\n  // Fees\n  error PoolFeeExceedsMax();\n  error MaxPoolFeeAbove100();\n\n  // Voting\n  error NxmIsLockedForGovernanceVote();\n  error ManagerNxmIsLockedForGovernanceVote();\n\n  // Deposit\n  error InsufficientDepositAmount();\n  error RewardRatioTooHigh();\n\n  // Staking NFTs\n  error InvalidTokenId();\n  error NotTokenOwnerOrApproved();\n  error InvalidStakingPoolForToken();\n\n  // Tranche & capacity\n  error NewTrancheEndsBeforeInitialTranche();\n  error RequestedTrancheIsNotYetActive();\n  error RequestedTrancheIsExpired();\n  error InsufficientCapacity();\n\n  // Allocation\n  error AlreadyDeallocated(uint allocationId);\n}\n"
    },
    "contracts/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IStakingPoolFactory {\n\n  function stakingPoolCount() external view returns (uint);\n\n  function beacon() external view returns (address);\n\n  function create(address beacon) external returns (uint poolId, address stakingPoolAddress);\n\n  event StakingPoolCreated(uint indexed poolId, address indexed stakingPoolAddress);\n}\n"
    },
    "contracts/interfaces/ITokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./INXMToken.sol\";\n\ninterface ITokenController {\n\n  struct StakingPoolNXMBalances {\n    uint128 rewards;\n    uint128 deposits;\n  }\n\n  struct CoverInfo {\n    uint16 claimCount;\n    bool hasOpenClaim;\n    bool hasAcceptedClaim;\n    uint96 requestedPayoutAmount;\n    // note: still 128 bits available here, can be used later\n  }\n\n  struct StakingPoolOwnershipOffer {\n    address proposedManager;\n    uint96 deadline;\n  }\n\n  struct WithdrawAssessment {\n    bool stake;\n    bool rewards;\n  }\n\n  /// @notice The stake deposit / rewards in a staking pool that will be withdrawn.\n  /// @dev    Call StakingViewer.getToken to get tokenId / trancheId information\n  /// @param tokenId The ID of the token stake deposit / rewards that will be withrawn.\n  /// @param trancheIds An array of tranche IDs representing the tranches where the stake was deposited.\n  struct StakingPoolDeposit {\n    uint tokenId;\n    uint[] trancheIds;\n  }\n\n  /// @notice Represents the rewards distributed to a staking pool manager.\n  /// @dev    Call StakingViewer.getManagerTokenRewardsByAddr to get poolId / trancheId information\n  /// @param poolId The ID of the pool managed by the manager.\n  /// @param trancheIds An array of tranche IDs representing the tranches where the manager rewards were distributed.\n  struct StakingPoolManagerReward {\n    uint poolId;\n    uint[] trancheIds;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function token() external view returns (INXMToken);\n\n  function coverInfo(uint id) external view returns (\n    uint16 claimCount,\n    bool hasOpenClaim,\n    bool hasAcceptedClaim,\n    uint96 requestedPayoutAmount\n  );\n\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\n\n  function totalSupply() external view returns (uint);\n\n  function totalBalanceOf(address _of) external view returns (uint amount);\n\n  function totalBalanceOfWithoutDelegations(address _of) external view returns (uint amount);\n\n  function getTokenPrice() external view returns (uint tokenPrice);\n\n  function getPendingRewards(address member) external view returns (uint);\n\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\n\n  function getWithdrawableCoverNotes(\n    address coverOwner\n  ) external view returns (\n    uint[] memory coverIds,\n    bytes32[] memory lockReasons,\n    uint withdrawableAmount\n  );\n\n  function getStakingPoolManager(uint poolId) external view returns (address manager);\n\n  function getManagerStakingPools(address manager) external view returns (uint[] memory poolIds);\n\n  function isStakingPoolManager(address member) external view returns (bool);\n\n  function getStakingPoolOwnershipOffer(uint poolId) external view returns (address proposedManager, uint deadline);\n\n  function stakingPoolNXMBalances(uint poolId) external view returns (uint128 rewards, uint128 deposits);\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function withdrawCoverNote(\n    address _of,\n    uint[] calldata _coverIds,\n    uint[] calldata _indexes\n  ) external;\n\n  function changeOperator(address _newOperator) external;\n\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\n\n  function burnFrom(address _of, uint amount) external returns (bool);\n\n  function addToWhitelist(address _member) external;\n\n  function removeFromWhitelist(address _member) external;\n\n  function mint(address _member, uint _amount) external;\n\n  function lockForMemberVote(address _of, uint _days) external;\n\n  function withdrawClaimAssessmentTokens(address[] calldata users) external;\n\n  function transferStakingPoolsOwnership(address from, address to) external;\n\n  function assignStakingPoolManager(uint poolId, address manager) external;\n\n  function createStakingPoolOwnershipOffer(uint poolId, address proposedManager, uint deadline) external;\n\n  function acceptStakingPoolOwnershipOffer(uint poolId) external;\n\n  function cancelStakingPoolOwnershipOffer(uint poolId) external;\n\n  function mintStakingPoolNXMRewards(uint amount, uint poolId) external;\n\n  function burnStakingPoolNXMRewards(uint amount, uint poolId) external;\n\n  function depositStakedNXM(address from, uint amount, uint poolId) external;\n\n  function withdrawNXMStakeAndRewards(address to, uint stakeToWithdraw, uint rewardsToWithdraw, uint poolId) external;\n\n  function burnStakedNXM(uint amount, uint poolId) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Simple library that defines min, max and babylonian sqrt functions\n */\nlibrary Math {\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function sum(uint[] memory items) internal pure returns (uint) {\n    uint count = items.length;\n    uint total;\n\n    for (uint i = 0; i < count; i++) {\n      total += items[i];\n    }\n\n    return total;\n  }\n\n  function divRound(uint a, uint b) internal pure returns (uint) {\n    return (a + b / 2) / b;\n  }\n\n  function divCeil(uint a, uint b) internal pure returns (uint) {\n    return (a + b - 1) / b;\n  }\n\n  function roundUp(uint a, uint b) internal pure returns (uint) {\n    return divCeil(a, b) * b;\n  }\n\n  // babylonian method\n  function sqrt(uint y) internal pure returns (uint) {\n\n    if (y > 3) {\n      uint z = y;\n      uint x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n      return z;\n    }\n\n    if (y != 0) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n}\n"
    },
    "contracts/libraries/SafeUintCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeUintCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value < 2**248, \"SafeCast: value doesn\\'t fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value < 2**240, \"SafeCast: value doesn\\'t fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value < 2**232, \"SafeCast: value doesn\\'t fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value < 2**224, \"SafeCast: value doesn\\'t fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value < 2**216, \"SafeCast: value doesn\\'t fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value < 2**208, \"SafeCast: value doesn\\'t fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value < 2**200, \"SafeCast: value doesn\\'t fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value < 2**192, \"SafeCast: value doesn\\'t fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value < 2**184, \"SafeCast: value doesn\\'t fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value < 2**176, \"SafeCast: value doesn\\'t fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value < 2**168, \"SafeCast: value doesn\\'t fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value < 2**160, \"SafeCast: value doesn\\'t fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value < 2**152, \"SafeCast: value doesn\\'t fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value < 2**144, \"SafeCast: value doesn\\'t fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value < 2**136, \"SafeCast: value doesn\\'t fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value < 2**120, \"SafeCast: value doesn\\'t fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value < 2**112, \"SafeCast: value doesn\\'t fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value < 2**104, \"SafeCast: value doesn\\'t fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value < 2**96, \"SafeCast: value doesn\\'t fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value < 2**88, \"SafeCast: value doesn\\'t fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value < 2**80, \"SafeCast: value doesn\\'t fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value < 2**56, \"SafeCast: value doesn\\'t fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value < 2**48, \"SafeCast: value doesn\\'t fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value < 2**40, \"SafeCast: value doesn\\'t fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value < 2**24, \"SafeCast: value doesn\\'t fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n    return uint8(value);\n  }\n}\n"
    },
    "contracts/modules/assessment/IndividualClaims.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"../../abstract/MasterAwareV2.sol\";\nimport \"../../interfaces/IAssessment.sol\";\nimport \"../../interfaces/ICover.sol\";\nimport \"../../interfaces/ICoverNFT.sol\";\nimport \"../../interfaces/IERC20Detailed.sol\";\nimport \"../../interfaces/IIndividualClaims.sol\";\nimport \"../../interfaces/INXMToken.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IRamm.sol\";\nimport \"../../interfaces/ICoverProducts.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../libraries/SafeUintCast.sol\";\n\n/// Provides a way for cover owners to submit claims and redeem payouts. It is an entry point to\n/// the assessment process where the members of the mutual decide the outcome of claims.\ncontract IndividualClaims is IIndividualClaims, MasterAwareV2 {\n\n  // 0-10000 bps (i.e. double decimal precision percentage)\n  uint internal constant MIN_ASSESSMENT_DEPOSIT_DENOMINATOR = 10000;\n  uint internal constant REWARD_DENOMINATOR = 10000;\n\n  // Used in operations involving NXM tokens and divisions\n  uint internal constant PRECISION = 10 ** 18;\n\n  INXMToken public immutable nxm;\n  ICoverNFT public immutable coverNFT;\n\n  /* ========== STATE VARIABLES ========== */\n\n  Configuration public override config;\n\n  Claim[] public override claims;\n\n  // Mapping from coverId to claimId used to check if a new claim can be submitted on the given\n  // cover as long as the last submitted claim reached a final state.\n  mapping(uint => ClaimSubmission) public lastClaimSubmissionOnCover;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(address nxmAddress, address coverNFTAddress) {\n    nxm = INXMToken(nxmAddress);\n    coverNFT = ICoverNFT(coverNFTAddress);\n  }\n\n  /* ========== VIEWS ========== */\n\n  function cover() internal view returns (ICover) {\n    return ICover(internalContracts[uint(ID.CO)]);\n  }\n\n  function coverProducts() internal view returns (ICoverProducts) {\n    return ICoverProducts(internalContracts[uint(ID.CP)]);\n  }\n\n  function assessment() internal view returns (IAssessment) {\n    return IAssessment(internalContracts[uint(ID.AS)]);\n  }\n\n  function pool() internal view returns (IPool) {\n    return IPool(internalContracts[uint(ID.P1)]);\n  }\n\n  function ramm() internal view returns (IRamm) {\n    return IRamm(internalContracts[uint(ID.RA)]);\n  }\n\n  function getClaimsCount() external override view returns (uint) {\n    return claims.length;\n  }\n\n  /// Returns the required assessment deposit and total reward for a new claim\n  ///\n  /// @dev This view is meant to be used either by users or user interfaces to determine the\n  /// minimum assessment deposit value of the submitClaim tx.\n  ///\n  /// @param requestedAmount  The amount that is claimed\n  /// @param segmentPeriod    The cover period of the segment in days\n  /// @param coverAsset      The asset in which the payout would be made\n  function getAssessmentDepositAndReward(\n    uint requestedAmount,\n    uint segmentPeriod,\n    uint coverAsset\n  ) public view returns (uint, uint) {\n    IPool poolContract = pool();\n\n    uint nxmPriceInETH = poolContract.getInternalTokenPriceInAsset(0);\n    uint nxmPriceInCoverAsset = coverAsset == 0\n      ? nxmPriceInETH\n      : poolContract.getInternalTokenPriceInAsset(coverAsset);\n\n    // Calculate the expected payout in NXM using the NXM price at cover purchase time\n    uint expectedPayoutInNXM = requestedAmount * PRECISION / nxmPriceInCoverAsset;\n\n    // Determine the total rewards that should be minted for the assessors based on cover period\n    uint totalRewardInNXM = Math.min(\n      uint(config.maxRewardInNXMWad) * PRECISION,\n      expectedPayoutInNXM * uint(config.rewardRatio) * segmentPeriod / 365 days / REWARD_DENOMINATOR\n    );\n\n    uint dynamicDeposit = totalRewardInNXM * nxmPriceInETH / PRECISION;\n    uint minDeposit = 1 ether * uint(config.minAssessmentDepositRatio) /\n      MIN_ASSESSMENT_DEPOSIT_DENOMINATOR;\n\n    // If dynamicDeposit falls below minDeposit use minDeposit instead\n    uint assessmentDepositInETH = Math.max(minDeposit, dynamicDeposit);\n\n    return (assessmentDepositInETH, totalRewardInNXM);\n  }\n\n  /// Returns a Claim aggregated in a human-friendly format.\n  ///\n  /// @dev This view is meant to be used in user interfaces to get a claim in a format suitable for\n  /// displaying all relevant information in as few calls as possible. See ClaimDisplay struct.\n  ///\n  /// @param id    Claim identifier for which the ClaimDisplay is returned\n  function getClaimDisplay(uint id) internal view returns (ClaimDisplay memory) {\n    Claim memory claim = claims[id];\n    (IAssessment.Poll memory poll,,) = assessment().assessments(claim.assessmentId);\n\n    ClaimStatus claimStatus = ClaimStatus.PENDING;\n    PayoutStatus payoutStatus = PayoutStatus.PENDING;\n    {\n      // Determine the claims status\n      if (block.timestamp >= poll.end) {\n        if (poll.accepted > poll.denied) {\n          claimStatus = ClaimStatus.ACCEPTED;\n        } else {\n          claimStatus = ClaimStatus.DENIED;\n        }\n      }\n\n      // Determine the payout status\n      if (claimStatus == ClaimStatus.ACCEPTED) {\n        if (claim.payoutRedeemed) {\n          payoutStatus = PayoutStatus.COMPLETE;\n        } else {\n          (,,uint8 payoutCooldownInDays,) = assessment().config();\n          if (\n            block.timestamp >= poll.end +\n            uint(payoutCooldownInDays) * 1 days +\n            uint(config.payoutRedemptionPeriodInDays) * 1 days\n          ) {\n            payoutStatus = PayoutStatus.UNCLAIMED;\n          }\n        }\n      } else if (claimStatus == ClaimStatus.DENIED) {\n        payoutStatus = PayoutStatus.DENIED;\n      }\n    }\n\n    CoverData memory coverData = cover().coverData(claim.coverId);\n\n    CoverSegment memory segment = cover().coverSegmentWithRemainingAmount(claim.coverId, claim.segmentId);\n\n    uint segmentEnd = segment.start + segment.period;\n\n    string memory assetSymbol;\n    if (claim.coverAsset == 0) {\n      assetSymbol = \"ETH\";\n    } else {\n\n      address assetAddress = pool().getAsset(claim.coverAsset).assetAddress;\n      try IERC20Detailed(assetAddress).symbol() returns (string memory v) {\n        assetSymbol = v;\n      } catch {\n        // return assetSymbol as an empty string and use claim.coverAsset instead in the UI\n      }\n    }\n\n    return ClaimDisplay(\n      id,\n      coverData.productId,\n      claim.coverId,\n      claim.assessmentId,\n      claim.amount,\n      assetSymbol,\n      claim.coverAsset,\n      segment.start,\n      segmentEnd,\n      poll.start,\n      poll.end,\n      uint(claimStatus),\n      uint(payoutStatus)\n    );\n  }\n\n  /// Returns an array of claims aggregated in a human-friendly format.\n  ///\n  /// @dev This view is meant to be used in user interfaces to get claims in a format suitable for\n  /// displaying all relevant information in as few calls as possible. It can be used to paginate\n  /// claims by providing the following parameters:\n  ///\n  /// @param ids   Array of Claim ids which are returned as ClaimDisplay\n  function getClaimsToDisplay (uint[] calldata ids)\n  external view returns (ClaimDisplay[] memory) {\n    ClaimDisplay[] memory claimDisplays = new ClaimDisplay[](ids.length);\n    for (uint i = 0; i < ids.length; i++) {\n      uint id = ids[i];\n      claimDisplays[i] = getClaimDisplay(id);\n    }\n    return claimDisplays;\n  }\n\n  /* === MUTATIVE FUNCTIONS ==== */\n\n  /// Submits a claim for assessment\n  ///\n  /// @dev This function requires an ETH assessment fee. See: getAssessmentDepositAndReward\n  ///\n  /// @param coverId          Cover identifier\n  /// @param requestedAmount  The amount expected to be received at payout\n  /// @param ipfsMetadata     An IPFS hash that stores metadata about the claim that is emitted as\n  ///                         an event. It's required for proof of loss. If this string is empty,\n  ///                         no event is emitted.\n  function submitClaim(\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 requestedAmount,\n    string calldata ipfsMetadata\n  ) external payable override onlyMember whenNotPaused returns (Claim memory claim) {\n    require(\n      coverNFT.isApprovedOrOwner(msg.sender, coverId),\n      \"Only the owner or approved addresses can submit a claim\"\n    );\n    return _submitClaim(coverId, segmentId, requestedAmount, ipfsMetadata, msg.sender);\n  }\n\n  function submitClaimFor(\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 requestedAmount,\n    string calldata ipfsMetadata,\n    address owner\n  ) external payable override onlyInternal whenNotPaused returns (Claim memory claim){\n    return _submitClaim(coverId, segmentId, requestedAmount, ipfsMetadata, owner);\n  }\n\n  function _submitClaim(\n    uint32 coverId,\n    uint16 segmentId,\n    uint96 requestedAmount,\n    string calldata ipfsMetadata,\n    address owner\n  ) internal returns (Claim memory) {\n    {\n      ClaimSubmission memory previousSubmission = lastClaimSubmissionOnCover[coverId];\n      if (previousSubmission.exists) {\n        uint80 assessmentId = claims[previousSubmission.claimId].assessmentId;\n        IAssessment.Poll memory poll = assessment().getPoll(assessmentId);\n        (,,uint8 payoutCooldownInDays,) = assessment().config();\n        uint payoutCooldown = uint(payoutCooldownInDays) * 1 days;\n        if (block.timestamp >= poll.end + payoutCooldown) {\n          if (\n            poll.accepted > poll.denied &&\n            block.timestamp < uint(poll.end) +\n            payoutCooldown +\n            uint(config.payoutRedemptionPeriodInDays) * 1 days\n          ) {\n            revert(\"A payout can still be redeemed\");\n          }\n        } else {\n          revert(\"A claim is already being assessed\");\n        }\n      }\n      lastClaimSubmissionOnCover[coverId] = ClaimSubmission(uint80(claims.length), true);\n    }\n\n    ICoverProducts coverProductsContract = coverProducts();\n    CoverData memory coverData = cover().coverData(coverId);\n    CoverSegment memory segment = cover().coverSegmentWithRemainingAmount(coverId, segmentId);\n\n    {\n      (, ProductType memory productType) = coverProductsContract.getProductWithType(coverData.productId);\n\n      require(\n        productType.claimMethod == uint8(ClaimMethod.IndividualClaims),\n        \"Invalid claim method for this product type\"\n      );\n      require(requestedAmount <= segment.amount, \"Covered amount exceeded\");\n      require(block.timestamp > segment.start, \"Cannot buy cover and submit claim in the same block\");\n      require(\n        uint(segment.start) + uint(segment.period) + uint(segment.gracePeriod) > block.timestamp,\n        \"Cover is outside the grace period\"\n      );\n\n      emit ClaimSubmitted(\n        owner,         // user\n        claims.length,      // claimId\n        coverId,            // coverId\n        coverData.productId // user\n      );\n    }\n\n    (uint assessmentDepositInETH, uint totalRewardInNXM) = getAssessmentDepositAndReward(\n      requestedAmount,\n      segment.period,\n      coverData.coverAsset\n    );\n\n    uint newAssessmentId = assessment().startAssessment(totalRewardInNXM, assessmentDepositInETH);\n\n    Claim memory claim = Claim({\n      assessmentId: SafeUintCast.toUint80(newAssessmentId),\n      coverId: coverId,\n      segmentId: segmentId,\n      amount: requestedAmount,\n      coverAsset: coverData.coverAsset,\n      payoutRedeemed: false\n    });\n    claims.push(claim);\n\n    if (bytes(ipfsMetadata).length > 0) {\n      emit MetadataSubmitted(claims.length - 1, ipfsMetadata);\n    }\n\n    require(msg.value >= assessmentDepositInETH, \"Assessment deposit is insufficient\");\n    if (msg.value > assessmentDepositInETH) {\n      // Refund ETH excess back to the sender\n      (\n        bool refunded,\n        /* bytes data */\n      ) = owner.call{value: msg.value - assessmentDepositInETH}(\"\");\n      require(refunded, \"Assessment deposit excess refund failed\");\n    }\n\n    // Transfer the assessment deposit to the pool\n    (\n      bool transferSucceeded,\n      /* bytes data */\n    ) =  getInternalContractAddress(ID.P1).call{value: assessmentDepositInETH}(\"\");\n    require(transferSucceeded, \"Assessment deposit transfer to pool failed\");\n\n    return claim;\n  }\n\n  /// Redeems payouts for accepted claims\n  ///\n  /// @dev Anyone can call this function, the payout always being transfered to the NFT owner.\n  /// When the tokens are transfered the assessment deposit is also sent back.\n  ///\n  /// @param claimId  Claim identifier\n  function redeemClaimPayout(uint104 claimId) external override whenNotPaused {\n    Claim memory claim = claims[claimId];\n    (\n      IAssessment.Poll memory poll,\n      /*uint128 totalAssessmentReward*/,\n      uint assessmentDepositInETH\n    ) = assessment().assessments(claim.assessmentId);\n\n    require(block.timestamp >= poll.end, \"The claim is still being assessed\");\n    require(poll.accepted > poll.denied, \"The claim needs to be accepted\");\n\n    (,,uint8 payoutCooldownInDays,) = assessment().config();\n    uint payoutCooldown = uint(payoutCooldownInDays) * 1 days;\n\n    require(block.timestamp >= poll.end + payoutCooldown, \"The claim is in cooldown period\");\n\n    require(\n      block.timestamp < uint(poll.end) + payoutCooldown + uint(config.payoutRedemptionPeriodInDays) * 1 days,\n      \"The redemption period has expired\"\n    );\n\n    require(!claim.payoutRedeemed, \"Payout has already been redeemed\");\n    claims[claimId].payoutRedeemed = true;\n\n    ramm().updateTwap();\n    address payable coverOwner = payable(cover().burnStake(\n      claim.coverId,\n      claim.segmentId,\n      claim.amount\n    ));\n\n    // Send payout in cover asset\n    pool().sendPayout(claim.coverAsset, coverOwner, claim.amount, assessmentDepositInETH);\n\n    emit ClaimPayoutRedeemed(coverOwner, claim.amount, claimId, claim.coverId);\n  }\n\n  /// Updates configurable aprameters through governance\n  ///\n  /// @param paramNames  An array of elements from UintParams enum\n  /// @param values      An array of the new values, each one corresponding to the parameter\n  ///                    from paramNames on the same position.\n  function updateUintParameters(\n    UintParams[] calldata paramNames,\n    uint[] calldata values\n  ) external override onlyGovernance {\n    Configuration memory newConfig = config;\n    for (uint i = 0; i < paramNames.length; i++) {\n      if (paramNames[i] == UintParams.payoutRedemptionPeriodInDays) {\n        newConfig.payoutRedemptionPeriodInDays = uint8(values[i]);\n        continue;\n      }\n      if (paramNames[i] == UintParams.rewardRatio) {\n        newConfig.rewardRatio = uint16(values[i]);\n        continue;\n      }\n      if (paramNames[i] == UintParams.maxRewardInNXMWad) {\n        newConfig.maxRewardInNXMWad = uint16(values[i]);\n        continue;\n      }\n      if (paramNames[i] == UintParams.minAssessmentDepositRatio) {\n        newConfig.minAssessmentDepositRatio = uint16(values[i]);\n        continue;\n      }\n    }\n    config = newConfig;\n  }\n\n  /// @dev Updates internal contract addresses to the ones stored in master. This function is\n  /// automatically called by the master contract when a contract is added or upgraded.\n  function changeDependentContractAddress() external override {\n    internalContracts[uint(ID.TC)] = master.getLatestAddress(\"TC\");\n    internalContracts[uint(ID.MR)] = master.getLatestAddress(\"MR\");\n    internalContracts[uint(ID.P1)] = master.getLatestAddress(\"P1\");\n    internalContracts[uint(ID.CO)] = master.getLatestAddress(\"CO\");\n    internalContracts[uint(ID.AS)] = master.getLatestAddress(\"AS\");\n    internalContracts[uint(ID.RA)] = master.getLatestAddress(\"RA\");\n    internalContracts[uint(ID.CP)] = master.getLatestAddress(\"CP\");\n\n    Configuration memory currentConfig = config;\n    bool notInitialized = bytes32(\n      abi.encodePacked(\n        currentConfig.rewardRatio,\n        currentConfig.maxRewardInNXMWad,\n        currentConfig.minAssessmentDepositRatio,\n        currentConfig.payoutRedemptionPeriodInDays\n      )\n    ) == bytes32(0);\n\n    if (notInitialized) {\n      // The minimum cover premium per year is 2.6%. 20% of the cover premium is: 2.6% * 20% = 0.52%\n      config.rewardRatio = 130; // 1.3%\n      config.maxRewardInNXMWad = 50; // 50 NXM\n      config.minAssessmentDepositRatio = 500; // 5% i.e. 0.05 ETH assessment minimum flat fee\n      config.payoutRedemptionPeriodInDays = 30; // days to redeem the payout\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}
{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-v4/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v4/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-v4/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v4/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/abstract/MasterAwareV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"../interfaces/INXMMaster.sol\";\nimport \"../interfaces/IMasterAwareV2.sol\";\nimport \"../interfaces/IMemberRoles.sol\";\n\nabstract contract MasterAwareV2 is IMasterAwareV2 {\n\n  INXMMaster public master;\n\n  mapping(uint => address payable) public internalContracts;\n\n  modifier onlyMember {\n    require(\n      IMemberRoles(internalContracts[uint(ID.MR)]).checkRole(\n        msg.sender,\n        uint(IMemberRoles.Role.Member)\n      ),\n      \"Caller is not a member\"\n    );\n    _;\n  }\n\n  modifier onlyAdvisoryBoard {\n    require(\n      IMemberRoles(internalContracts[uint(ID.MR)]).checkRole(\n        msg.sender,\n        uint(IMemberRoles.Role.AdvisoryBoard)\n      ),\n      \"Caller is not an advisory board member\"\n    );\n    _;\n  }\n\n  modifier onlyInternal {\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\n    _;\n  }\n\n  modifier onlyMaster {\n    if (address(master) != address(0)) {\n      require(address(master) == msg.sender, \"Not master\");\n    }\n    _;\n  }\n\n  modifier onlyGovernance {\n    require(\n      master.checkIsAuthToGoverned(msg.sender),\n      \"Caller is not authorized to govern\"\n    );\n    _;\n  }\n\n  modifier onlyEmergencyAdmin {\n    require(\n      msg.sender == master.emergencyAdmin(),\n      \"Caller is not emergency admin\"\n    );\n    _;\n  }\n\n  modifier whenPaused {\n    require(master.isPause(), \"System is not paused\");\n    _;\n  }\n\n  modifier whenNotPaused {\n    require(!master.isPause(), \"System is paused\");\n    _;\n  }\n\n  function getInternalContractAddress(ID id) internal view returns (address payable) {\n    return internalContracts[uint(id)];\n  }\n\n  function changeMasterAddress(address masterAddress) public onlyMaster {\n    master = INXMMaster(masterAddress);\n  }\n\n}\n"
    },
    "contracts/external/cow/GPv2Order.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts-v4/token/ERC20/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable\" +\n    ///         \"string sellTokenBalance\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner)\n        internal\n        pure\n        returns (address receiver)\n    {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator)\n        internal\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(bytes calldata orderUid)\n        internal\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n"
    },
    "contracts/external/enzyme/IEnzymeFundValueCalculatorRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IEnzymeFundValueCalculatorRouter {\n  function calcGrossShareValue(address _vaultProxy)\n  external\n  returns (address denominationAsset_, uint256 grossShareValue_);\n\n  function calcNetShareValue(address _vaultProxy)\n  external\n  returns (address denominationAsset_, uint256 netShareValue_);\n}\n\n\n"
    },
    "contracts/interfaces/ICowSettlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IERC20Detailed.sol\";\n\ninterface ICowSettlement {\n\n  struct GPv2TradeData {\n    uint256 sellTokenIndex;\n    uint256 buyTokenIndex;\n    address receiver;\n    uint256 sellAmount;\n    uint256 buyAmount;\n    uint32 validTo;\n    bytes32 appData;\n    uint256 feeAmount;\n    uint256 flags;\n    uint256 executedAmount;\n    bytes signature;\n  }\n\n  struct GPv2InteractionData {\n    address target;\n    uint256 value;\n    bytes callData;\n  }\n\n  function setPreSignature(bytes calldata orderUid, bool signed) external;\n  \n  function invalidateOrder(bytes calldata orderUid) external; \n\n  function filledAmount(bytes calldata orderUid) external view returns (uint256);\n\n  function vaultRelayer() external view returns (address);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function settle(\n    IERC20Detailed[] calldata tokens,\n    uint256[] calldata clearingPrices,\n    GPv2TradeData[] calldata trades,\n    GPv2InteractionData[][3] calldata interactions\n  ) external;\n\n  function preSignature(bytes memory) external returns (uint);\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IERC20Detailed {\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function decimals() external view returns (uint8);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ILegacyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPriceFeedOracle.sol\";\n\ninterface ILegacyPool {\n\n  struct SwapDetails {\n    uint104 minAmount;\n    uint104 maxAmount;\n    uint32 lastSwapTime;\n    // 2 decimals of precision. 0.01% -> 0.0001 -> 1e14\n    uint16 maxSlippageRatio;\n  }\n\n  struct Asset {\n    address assetAddress;\n    bool isCoverAsset;\n    bool isAbandoned;\n  }\n\n  function getAsset(uint assetId) external view returns (Asset memory);\n\n  function getAssets() external view returns (Asset[] memory);\n\n  function buyNXM(uint minTokensOut) external payable;\n\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\n\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\n\n  function transferAssetToSwapOperator(address asset, uint amount) external;\n\n  function setSwapDetailsLastSwapTime(address asset, uint32 lastSwapTime) external;\n\n  function getAssetSwapDetails(address assetAddress) external view returns (SwapDetails memory);\n\n  function getNXMForEth(uint ethAmount) external view returns (uint);\n\n  function sendPayout(uint assetIndex, address payable payoutAddress, uint amount) external;\n\n  function upgradeCapitalPool(address payable newPoolAddress) external;\n\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\n\n  function getPoolValueInEth() external view returns (uint);\n\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\n\n  function calculateEthForNXM(uint nxmAmount, uint currentTotalAssetValue, uint mcrEth) external pure returns (uint);\n\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\n\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\n\n  function getTokenPriceInAsset(uint assetId) external view returns (uint tokenPrice);\n\n  function getTokenPrice() external view returns (uint tokenPrice);\n\n  function getMCRRatio() external view returns (uint);\n\n  function setSwapValue(uint value) external;\n}\n"
    },
    "contracts/interfaces/IMasterAwareV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IMasterAwareV2 {\n\n  // TODO: if you update this enum, update lib/constants.js as well\n  enum ID {\n    TC, // TokenController.sol\n    P1, // Pool.sol\n    MR, // MemberRoles.sol\n    MC, // MCR.sol\n    CO, // Cover.sol\n    SP, // StakingProducts.sol\n    PS, // LegacyPooledStaking.sol\n    GV, // Governance.sol\n    GW, // LegacyGateway.sol - removed\n    CL, // CoverMigrator.sol - removed\n    AS, // Assessment.sol\n    CI, // IndividualClaims.sol - Claims for Individuals\n    CG, // YieldTokenIncidents.sol - Claims for Groups\n    RA, // Ramm.sol\n    ST,  // SafeTracker.sol\n    CP  // CoverProducts.sol\n  }\n\n  function changeMasterAddress(address masterAddress) external;\n\n  function changeDependentContractAddress() external;\n\n  function internalContracts(uint) external view returns (address payable);\n}\n"
    },
    "contracts/interfaces/IMCR.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IMCR {\n\n  function updateMCRInternal(bool forceUpdate) external;\n\n  function getMCR() external view returns (uint);\n\n  function mcr() external view returns (uint80);\n\n  function desiredMCR() external view returns (uint80);\n\n  function lastUpdateTime() external view returns (uint32);\n\n  function maxMCRIncrement() external view returns (uint16);\n\n  function gearingFactor() external view returns (uint24);\n\n  function minUpdateTime() external view returns (uint16);\n\n}\n"
    },
    "contracts/interfaces/IMemberRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IMemberRoles {\n\n  enum Role {Unassigned, AdvisoryBoard, Member, Owner}\n\n  function join(address _userAddress, uint nonce, bytes calldata signature) external payable;\n\n  function switchMembership(address _newAddress) external;\n\n  function switchMembershipAndAssets(\n    address newAddress,\n    uint[] calldata coverIds,\n    uint[] calldata stakingTokenIds\n  ) external;\n\n  function switchMembershipOf(address member, address _newAddress) external;\n\n  function totalRoles() external view returns (uint256);\n\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\n\n  function setKycAuthAddress(address _add) external;\n\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\n\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\n\n  function authorized(uint _memberRoleId) external view returns (address);\n\n  function roles(address _memberAddress) external view returns (uint[] memory);\n\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\n\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\n\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\n\n  function membersLength(uint _memberRoleId) external view returns (uint);\n\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n\n  event MemberJoined(address indexed newMember, uint indexed nonce);\n\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\n  \n  event MembershipWithdrawn(address indexed member, uint timestamp);\n}\n"
    },
    "contracts/interfaces/INXMMaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface INXMMaster {\n\n  function tokenAddress() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function emergencyAdmin() external view returns (address);\n\n  function masterInitialized() external view returns (bool);\n\n  function isInternal(address _add) external view returns (bool);\n\n  function isPause() external view returns (bool check);\n\n  function isMember(address _add) external view returns (bool);\n\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\n\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\n\n  function contractAddresses(bytes2 code) external view returns (address payable);\n\n  function upgradeMultipleContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses\n  ) external;\n\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\n\n  function addNewInternalContracts(\n    bytes2[] calldata _contractCodes,\n    address payable[] calldata newAddresses,\n    uint[] calldata _types\n  ) external;\n\n  function updateOwnerParameters(bytes8 code, address payable val) external;\n}\n"
    },
    "contracts/interfaces/INXMToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface INXMToken {\n\n  function burn(uint256 amount) external returns (bool);\n\n  function burnFrom(address from, uint256 value) external returns (bool);\n\n  function operatorTransfer(address from, uint256 value) external returns (bool);\n\n  function mint(address account, uint256 amount) external;\n\n  function isLockedForMV(address member) external view returns (uint);\n\n  function whiteListed(address member) external view returns (bool);\n\n  function addToWhiteList(address _member) external returns (bool);\n\n  function removeFromWhiteList(address _member) external returns (bool);\n\n  function changeOperator(address _newOperator) external returns (bool);\n\n  function lockForMemberVote(address _of, uint _days) external;\n\n  /**\n * @dev Returns the amount of tokens in existence.\n */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPriceFeedOracle.sol\";\n\nstruct SwapDetails {\n  uint104 minAmount;\n  uint104 maxAmount;\n  uint32 lastSwapTime;\n  // 2 decimals of precision. 0.01% -> 0.0001 -> 1e14\n  uint16 maxSlippageRatio;\n}\n\nstruct Asset {\n  address assetAddress;\n  bool isCoverAsset;\n  bool isAbandoned;\n}\n\ninterface IPool {\n\n  error RevertedWithoutReason(uint index);\n  error AssetNotFound();\n  error UnknownParameter();\n  error OrderInProgress();\n\n  function swapOperator() external view returns (address);\n\n  function getAsset(uint assetId) external view returns (Asset memory);\n\n  function getAssets() external view returns (Asset[] memory);\n\n  function transferAssetToSwapOperator(address asset, uint amount) external;\n\n  function setSwapDetailsLastSwapTime(address asset, uint32 lastSwapTime) external;\n\n  function getAssetSwapDetails(address assetAddress) external view returns (SwapDetails memory);\n\n  function sendPayout(uint assetIndex, address payable payoutAddress, uint amount, uint ethDepositAmount) external;\n\n  function sendEth(address payoutAddress, uint amount) external;\n\n  function upgradeCapitalPool(address payable newPoolAddress) external;\n\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\n\n  function getPoolValueInEth() external view returns (uint);\n\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\n\n  function getInternalTokenPriceInAsset(uint assetId) external view returns (uint tokenPrice);\n\n  function getInternalTokenPriceInAssetAndUpdateTwap(uint assetId) external returns (uint tokenPrice);\n\n  function getTokenPrice() external view returns (uint tokenPrice);\n\n  function getMCRRatio() external view returns (uint);\n\n  function setSwapAssetAmount(address assetAddress, uint value) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeedOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface Aggregator {\n  function decimals() external view returns (uint8);\n  function latestAnswer() external view returns (int);\n}\n\ninterface IPriceFeedOracle {\n\n  struct OracleAsset {\n    Aggregator aggregator;\n    uint8 decimals;\n  }\n\n  function ETH() external view returns (address);\n  function assets(address) external view returns (Aggregator, uint8);\n\n  function getAssetToEthRate(address asset) external view returns (uint);\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\n  function getEthForAsset(address asset, uint amount) external view returns (uint);\n\n}\n"
    },
    "contracts/interfaces/IRamm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./IPool.sol\";\nimport \"./INXMToken.sol\";\nimport \"./ITokenController.sol\";\n\ninterface IRamm {\n\n  // storage structs\n\n  struct Slot0 {\n    uint128 nxmReserveA;\n    uint128 nxmReserveB;\n  }\n\n  struct Slot1 {\n    uint128 ethReserve;\n    uint88 budget;\n    uint32 updatedAt;\n    bool swapPaused; // emergency pause\n  }\n\n  struct Observation {\n    uint32 timestamp;\n    uint112 priceCumulativeAbove;\n    uint112 priceCumulativeBelow;\n  }\n\n  // memory structs\n\n  struct State {\n    uint nxmA;\n    uint nxmB;\n    uint eth;\n    uint budget;\n    uint ratchetSpeedB;\n    uint timestamp;\n  }\n\n  struct Context {\n    uint capital;\n    uint supply;\n    uint mcr;\n  }\n\n  struct CumulativePriceCalculationProps {\n    uint previousEthReserve;\n    uint currentEthReserve;\n    uint previousNxmA;\n    uint currentNxmA;\n    uint previousNxmB;\n    uint currentNxmB;\n    uint previousTimestamp;\n    uint observationTimestamp;\n  }\n\n  struct CumulativePriceCalculationTimes {\n    uint secondsUntilBVAbove;\n    uint secondsUntilBVBelow;\n    uint timeElapsed;\n    uint bvTimeBelow;\n    uint bvTimeAbove;\n    uint ratchetTimeAbove;\n    uint ratchetTimeBelow;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function getReserves() external view returns (\n    uint ethReserve,\n    uint nxmA,\n    uint nxmB,\n    uint remainingBudget\n  );\n\n  function getSpotPrices() external view returns (uint spotPriceA, uint spotPriceB);\n\n  function getBookValue() external view returns (uint bookValue);\n\n  function getInternalPrice() external view returns (uint internalPrice);\n\n  /* ==== MUTATIVE FUNCTIONS ==== */\n\n  function updateTwap() external;\n\n  function getInternalPriceAndUpdateTwap() external returns (uint internalPrice);\n\n  function swap(uint nxmIn, uint minAmountOut, uint deadline) external payable returns (uint amountOut);\n\n  function removeBudget() external;\n\n  function setEmergencySwapPause(bool _swapPaused) external;\n\n  /* ========== EVENTS AND ERRORS ========== */\n\n  event EthSwappedForNxm(address indexed member, uint ethIn, uint nxmOut);\n  event NxmSwappedForEth(address indexed member, uint nxmIn, uint ethOut);\n  event ObservationUpdated(uint32 timestamp, uint112 priceCumulativeAbove, uint112 priceCumulativeBelow);\n  event BudgetRemoved();\n  event SwapPauseConfigured(bool paused);\n  event EthInjected(uint value);\n  event EthExtracted(uint value);\n\n  // Pause\n  error SystemPaused();\n  error SwapPaused();\n\n  // Input\n  error OneInputOnly();\n  error OneInputRequired();\n\n  // Expiry\n  error SwapExpired(uint deadline, uint blockTimestamp);\n\n  // Insufficient amount out\n  error InsufficientAmountOut(uint amountOut, uint minAmountOut);\n\n  // Buffer Zone\n  error NoSwapsInBufferZone();\n\n  // ETH Transfer\n  error EthTransferFailed();\n\n  // Circuit breakers\n  error EthCircuitBreakerHit();\n  error NxmCircuitBreakerHit();\n}\n"
    },
    "contracts/interfaces/ISwapOperator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"../external/cow/GPv2Order.sol\";\nimport \"../external/enzyme/IEnzymeFundValueCalculatorRouter.sol\";\nimport \"./ICowSettlement.sol\";\nimport \"./INXMMaster.sol\";\nimport \"./IPool.sol\";\nimport \"./IWeth.sol\";\n\ninterface ISwapOperator {\n\n  enum SwapOperationType {\n    EthToAsset,\n    AssetToEth,\n    AssetToAsset\n  }\n\n  /* ========== VIEWS ========== */\n\n  function getDigest(GPv2Order.Data calldata order) external view returns (bytes32);\n\n  function getUID(GPv2Order.Data calldata order) external view returns (bytes memory);\n\n  function orderInProgress() external view returns (bool);\n\n  function currentOrderUID() external view returns (bytes memory);\n\n  /* ========== IMMUTABLES ========== */\n\n  function cowSettlement() external view returns (ICowSettlement);\n\n  function cowVaultRelayer() external view returns (address);\n\n  function master() external view returns (INXMMaster);\n\n  function swapController() external view returns (address);\n\n  function weth() external view returns (IWeth);\n\n  function domainSeparator() external view returns (bytes32);\n\n  function enzymeV4VaultProxyAddress() external view returns (address);\n\n  function enzymeFundValueCalculatorRouter() external view returns (IEnzymeFundValueCalculatorRouter);\n\n  function minPoolEth() external view returns (uint);\n\n  /* ==== MUTATIVE FUNCTIONS ==== */\n\n  function placeOrder(GPv2Order.Data calldata order, bytes calldata orderUID) external;\n\n  function closeOrder(GPv2Order.Data calldata order) external;\n\n  function swapEnzymeVaultShareForETH(uint amountIn, uint amountOutMin) external;\n\n  function swapETHForEnzymeVaultShare(uint amountIn, uint amountOutMin) external;\n\n  function recoverAsset(address assetAddress, address receiver) external;\n\n  function requestAsset(address asset, uint amount) external;\n\n  function transferRequestedAsset(address requestedAsset, uint requestedAmount) external;\n\n  /* ========== EVENTS AND ERRORS ========== */\n\n  event OrderPlaced(GPv2Order.Data order);\n  event OrderClosed(GPv2Order.Data order, uint filledAmount);\n  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);\n  event TransferredToSafe(address asset, uint amount);\n\n  // Swap Order\n  error OrderInProgress(bytes currentOrderUID);\n  error NoOrderInPlace();\n  error OrderUidMismatch(bytes providedOrderUID, bytes expectedOrderUID);\n  error UnsupportedTokenBalance(string kind);\n  error InvalidReceiver(address validReceiver);\n  error TokenDisabled(address token);\n  error AmountOutTooLow(uint amountOut, uint minAmount);\n  error InvalidTokenAddress(string token);\n  error InvalidDenominationAsset(address invalidAsset, address validAsset);\n\n  // Valid To\n  error BelowMinValidTo(uint minValidTo);\n  error AboveMaxValidTo(uint maxValidTo);\n\n  // Balance\n  error InvalidBalance(uint tokenBalance, uint limit);\n  error InvalidPostSwapBalance(uint postSwapBalance, uint limit);\n\n  // Access Controls\n  error OnlyController();\n\n  // Transfer\n  error TransferFailed(address to, uint value, address token);\n\n  // Cool down\n  error InsufficientTimeBetweenSwaps(uint minValidSwapTime);\n\n  // Fee\n  error AboveMaxFee(uint feeInEth, uint maxFee);\n}\n"
    },
    "contracts/interfaces/ITokenController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\nimport \"./INXMToken.sol\";\n\ninterface ITokenController {\n\n  struct StakingPoolNXMBalances {\n    uint128 rewards;\n    uint128 deposits;\n  }\n\n  struct CoverInfo {\n    uint16 claimCount;\n    bool hasOpenClaim;\n    bool hasAcceptedClaim;\n    uint96 requestedPayoutAmount;\n    // note: still 128 bits available here, can be used later\n  }\n\n  struct StakingPoolOwnershipOffer {\n    address proposedManager;\n    uint96 deadline;\n  }\n\n  struct WithdrawAssessment {\n    bool stake;\n    bool rewards;\n  }\n\n  /// @notice The stake deposit / rewards in a staking pool that will be withdrawn.\n  /// @dev    Call StakingViewer.getToken to get tokenId / trancheId information\n  /// @param tokenId The ID of the token stake deposit / rewards that will be withrawn.\n  /// @param trancheIds An array of tranche IDs representing the tranches where the stake was deposited.\n  struct StakingPoolDeposit {\n    uint tokenId;\n    uint[] trancheIds;\n  }\n\n  /// @notice Represents the rewards distributed to a staking pool manager.\n  /// @dev    Call StakingViewer.getManagerTokenRewardsByAddr to get poolId / trancheId information\n  /// @param poolId The ID of the pool managed by the manager.\n  /// @param trancheIds An array of tranche IDs representing the tranches where the manager rewards were distributed.\n  struct StakingPoolManagerReward {\n    uint poolId;\n    uint[] trancheIds;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function token() external view returns (INXMToken);\n\n  function coverInfo(uint id) external view returns (\n    uint16 claimCount,\n    bool hasOpenClaim,\n    bool hasAcceptedClaim,\n    uint96 requestedPayoutAmount\n  );\n\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\n\n  function totalSupply() external view returns (uint);\n\n  function totalBalanceOf(address _of) external view returns (uint amount);\n\n  function totalBalanceOfWithoutDelegations(address _of) external view returns (uint amount);\n\n  function getTokenPrice() external view returns (uint tokenPrice);\n\n  function getPendingRewards(address member) external view returns (uint);\n\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\n\n  function getWithdrawableCoverNotes(\n    address coverOwner\n  ) external view returns (\n    uint[] memory coverIds,\n    bytes32[] memory lockReasons,\n    uint withdrawableAmount\n  );\n\n  function getStakingPoolManager(uint poolId) external view returns (address manager);\n\n  function getManagerStakingPools(address manager) external view returns (uint[] memory poolIds);\n\n  function isStakingPoolManager(address member) external view returns (bool);\n\n  function getStakingPoolOwnershipOffer(uint poolId) external view returns (address proposedManager, uint deadline);\n\n  function stakingPoolNXMBalances(uint poolId) external view returns (uint128 rewards, uint128 deposits);\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function withdrawCoverNote(\n    address _of,\n    uint[] calldata _coverIds,\n    uint[] calldata _indexes\n  ) external;\n\n  function changeOperator(address _newOperator) external;\n\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\n\n  function burnFrom(address _of, uint amount) external returns (bool);\n\n  function addToWhitelist(address _member) external;\n\n  function removeFromWhitelist(address _member) external;\n\n  function mint(address _member, uint _amount) external;\n\n  function lockForMemberVote(address _of, uint _days) external;\n\n  function withdrawClaimAssessmentTokens(address[] calldata users) external;\n\n  function transferStakingPoolsOwnership(address from, address to) external;\n\n  function assignStakingPoolManager(uint poolId, address manager) external;\n\n  function createStakingPoolOwnershipOffer(uint poolId, address proposedManager, uint deadline) external;\n\n  function acceptStakingPoolOwnershipOffer(uint poolId) external;\n\n  function cancelStakingPoolOwnershipOffer(uint poolId) external;\n\n  function mintStakingPoolNXMRewards(uint amount, uint poolId) external;\n\n  function burnStakingPoolNXMRewards(uint amount, uint poolId) external;\n\n  function depositStakedNXM(address from, uint amount, uint poolId) external;\n\n  function withdrawNXMStakeAndRewards(address to, uint stakeToWithdraw, uint rewardsToWithdraw, uint poolId) external;\n\n  function burnStakedNXM(uint amount, uint poolId) external;\n}\n"
    },
    "contracts/interfaces/IWeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.5.0;\n\ninterface IWeth {\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function approve(address spender, uint256 value) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Simple library that defines min, max and babylonian sqrt functions\n */\nlibrary Math {\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function sum(uint[] memory items) internal pure returns (uint) {\n    uint count = items.length;\n    uint total;\n\n    for (uint i = 0; i < count; i++) {\n      total += items[i];\n    }\n\n    return total;\n  }\n\n  function divRound(uint a, uint b) internal pure returns (uint) {\n    return (a + b / 2) / b;\n  }\n\n  function divCeil(uint a, uint b) internal pure returns (uint) {\n    return (a + b - 1) / b;\n  }\n\n  function roundUp(uint a, uint b) internal pure returns (uint) {\n    return divCeil(a, b) * b;\n  }\n\n  // babylonian method\n  function sqrt(uint y) internal pure returns (uint) {\n\n    if (y > 3) {\n      uint z = y;\n      uint x = y / 2 + 1;\n      while (x < z) {\n        z = x;\n        x = (y / x + x) / 2;\n      }\n      return z;\n    }\n\n    if (y != 0) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n}\n"
    },
    "contracts/libraries/SafeUintCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeUintCast {\n  /**\n   * @dev Returns the downcasted uint248 from uint256, reverting on\n   * overflow (when the input is greater than largest uint248).\n   *\n   * Counterpart to Solidity's `uint248` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 248 bits\n   */\n  function toUint248(uint256 value) internal pure returns (uint248) {\n    require(value < 2**248, \"SafeCast: value doesn\\'t fit in 248 bits\");\n    return uint248(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint240 from uint256, reverting on\n   * overflow (when the input is greater than largest uint240).\n   *\n   * Counterpart to Solidity's `uint240` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 240 bits\n   */\n  function toUint240(uint256 value) internal pure returns (uint240) {\n    require(value < 2**240, \"SafeCast: value doesn\\'t fit in 240 bits\");\n    return uint240(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint232 from uint256, reverting on\n   * overflow (when the input is greater than largest uint232).\n   *\n   * Counterpart to Solidity's `uint232` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 232 bits\n   */\n  function toUint232(uint256 value) internal pure returns (uint232) {\n    require(value < 2**232, \"SafeCast: value doesn\\'t fit in 232 bits\");\n    return uint232(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value < 2**224, \"SafeCast: value doesn\\'t fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint216 from uint256, reverting on\n   * overflow (when the input is greater than largest uint216).\n   *\n   * Counterpart to Solidity's `uint216` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 216 bits\n   */\n  function toUint216(uint256 value) internal pure returns (uint216) {\n    require(value < 2**216, \"SafeCast: value doesn\\'t fit in 216 bits\");\n    return uint216(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint208 from uint256, reverting on\n   * overflow (when the input is greater than largest uint208).\n   *\n   * Counterpart to Solidity's `uint208` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 208 bits\n   */\n  function toUint208(uint256 value) internal pure returns (uint208) {\n    require(value < 2**208, \"SafeCast: value doesn\\'t fit in 208 bits\");\n    return uint208(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint200 from uint256, reverting on\n   * overflow (when the input is greater than largest uint200).\n   *\n   * Counterpart to Solidity's `uint200` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 200 bits\n   */\n  function toUint200(uint256 value) internal pure returns (uint200) {\n    require(value < 2**200, \"SafeCast: value doesn\\'t fit in 200 bits\");\n    return uint200(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint192 from uint256, reverting on\n   * overflow (when the input is greater than largest uint192).\n   *\n   * Counterpart to Solidity's `uint192` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 192 bits\n   */\n  function toUint192(uint256 value) internal pure returns (uint192) {\n    require(value < 2**192, \"SafeCast: value doesn\\'t fit in 192 bits\");\n    return uint192(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint184 from uint256, reverting on\n   * overflow (when the input is greater than largest uint184).\n   *\n   * Counterpart to Solidity's `uint184` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 184 bits\n   */\n  function toUint184(uint256 value) internal pure returns (uint184) {\n    require(value < 2**184, \"SafeCast: value doesn\\'t fit in 184 bits\");\n    return uint184(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint176 from uint256, reverting on\n   * overflow (when the input is greater than largest uint176).\n   *\n   * Counterpart to Solidity's `uint176` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 176 bits\n   */\n  function toUint176(uint256 value) internal pure returns (uint176) {\n    require(value < 2**176, \"SafeCast: value doesn\\'t fit in 176 bits\");\n    return uint176(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint168 from uint256, reverting on\n   * overflow (when the input is greater than largest uint168).\n   *\n   * Counterpart to Solidity's `uint168` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 168 bits\n   */\n  function toUint168(uint256 value) internal pure returns (uint168) {\n    require(value < 2**168, \"SafeCast: value doesn\\'t fit in 168 bits\");\n    return uint168(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint160 from uint256, reverting on\n   * overflow (when the input is greater than largest uint160).\n   *\n   * Counterpart to Solidity's `uint160` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 160 bits\n   */\n  function toUint160(uint256 value) internal pure returns (uint160) {\n    require(value < 2**160, \"SafeCast: value doesn\\'t fit in 160 bits\");\n    return uint160(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint152 from uint256, reverting on\n   * overflow (when the input is greater than largest uint152).\n   *\n   * Counterpart to Solidity's `uint152` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 152 bits\n   */\n  function toUint152(uint256 value) internal pure returns (uint152) {\n    require(value < 2**152, \"SafeCast: value doesn\\'t fit in 152 bits\");\n    return uint152(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint144 from uint256, reverting on\n   * overflow (when the input is greater than largest uint144).\n   *\n   * Counterpart to Solidity's `uint144` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 144 bits\n   */\n  function toUint144(uint256 value) internal pure returns (uint144) {\n    require(value < 2**144, \"SafeCast: value doesn\\'t fit in 144 bits\");\n    return uint144(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint136 from uint256, reverting on\n   * overflow (when the input is greater than largest uint136).\n   *\n   * Counterpart to Solidity's `uint136` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 136 bits\n   */\n  function toUint136(uint256 value) internal pure returns (uint136) {\n    require(value < 2**136, \"SafeCast: value doesn\\'t fit in 136 bits\");\n    return uint136(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint120 from uint256, reverting on\n   * overflow (when the input is greater than largest uint120).\n   *\n   * Counterpart to Solidity's `uint120` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 120 bits\n   */\n  function toUint120(uint256 value) internal pure returns (uint120) {\n    require(value < 2**120, \"SafeCast: value doesn\\'t fit in 120 bits\");\n    return uint120(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint112 from uint256, reverting on\n   * overflow (when the input is greater than largest uint112).\n   *\n   * Counterpart to Solidity's `uint112` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 112 bits\n   */\n  function toUint112(uint256 value) internal pure returns (uint112) {\n    require(value < 2**112, \"SafeCast: value doesn\\'t fit in 112 bits\");\n    return uint112(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint104 from uint256, reverting on\n   * overflow (when the input is greater than largest uint104).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 104 bits\n   */\n  function toUint104(uint256 value) internal pure returns (uint104) {\n    require(value < 2**104, \"SafeCast: value doesn\\'t fit in 104 bits\");\n    return uint104(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value < 2**96, \"SafeCast: value doesn\\'t fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint88 from uint256, reverting on\n   * overflow (when the input is greater than largest uint88).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 88 bits\n   */\n  function toUint88(uint256 value) internal pure returns (uint88) {\n    require(value < 2**88, \"SafeCast: value doesn\\'t fit in 88 bits\");\n    return uint88(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint80 from uint256, reverting on\n   * overflow (when the input is greater than largest uint80).\n   *\n   * Counterpart to Solidity's `uint104` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 80 bits\n   */\n  function toUint80(uint256 value) internal pure returns (uint80) {\n    require(value < 2**80, \"SafeCast: value doesn\\'t fit in 80 bits\");\n    return uint80(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint56 from uint256, reverting on\n   * overflow (when the input is greater than largest uint56).\n   *\n   * Counterpart to Solidity's `uint56` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 56 bits\n   */\n  function toUint56(uint256 value) internal pure returns (uint56) {\n    require(value < 2**56, \"SafeCast: value doesn\\'t fit in 56 bits\");\n    return uint56(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint48 from uint256, reverting on\n   * overflow (when the input is greater than largest uint48).\n   *\n   * Counterpart to Solidity's `uint48` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 48 bits\n   */\n  function toUint48(uint256 value) internal pure returns (uint48) {\n    require(value < 2**48, \"SafeCast: value doesn\\'t fit in 48 bits\");\n    return uint48(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint40 from uint256, reverting on\n   * overflow (when the input is greater than largest uint40).\n   *\n   * Counterpart to Solidity's `uint40` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 40 bits\n   */\n  function toUint40(uint256 value) internal pure returns (uint40) {\n    require(value < 2**40, \"SafeCast: value doesn\\'t fit in 40 bits\");\n    return uint40(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint24 from uint256, reverting on\n   * overflow (when the input is greater than largest uint24).\n   *\n   * Counterpart to Solidity's `uint24` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 24 bits\n   */\n  function toUint24(uint256 value) internal pure returns (uint24) {\n    require(value < 2**24, \"SafeCast: value doesn\\'t fit in 24 bits\");\n    return uint24(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n    return uint8(value);\n  }\n}\n"
    },
    "contracts/modules/capital/Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts-v4/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-v4/security/ReentrancyGuard.sol\";\n\nimport \"../../abstract/MasterAwareV2.sol\";\nimport \"../../interfaces/IMCR.sol\";\nimport \"../../interfaces/IRamm.sol\";\nimport \"../../interfaces/INXMToken.sol\";\nimport \"../../interfaces/ILegacyPool.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IPriceFeedOracle.sol\";\nimport \"../../interfaces/ISwapOperator.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../libraries/SafeUintCast.sol\";\n\ncontract Pool is IPool, MasterAwareV2, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using SafeUintCast for uint;\n\n  /* storage */\n\n  Asset[] public assets;\n  mapping(address => SwapDetails) public swapDetails;\n\n  // parameters\n  IPriceFeedOracle public override priceFeedOracle;\n  address public swapOperator;\n\n  // SwapOperator assets\n  uint32 public assetsInSwapOperatorBitmap;\n  uint public assetInSwapOperator;\n\n  /* constants */\n\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  uint public constant MCR_RATIO_DECIMALS = 4;\n  uint internal constant MAX_SLIPPAGE_DENOMINATOR = 10000;\n\n  INXMToken public immutable nxmToken;\n\n  /* events */\n  event Payout(address indexed to, address indexed assetAddress, uint amount);\n  event DepositReturned(address indexed to, uint amount);\n\n  /* logic */\n  modifier onlySwapOperator {\n    require(msg.sender == swapOperator, \"Pool: Not swapOperator\");\n    _;\n  }\n\n  modifier onlyRamm {\n    require(msg.sender == internalContracts[uint(ID.RA)], \"Pool: Not Ramm\");\n    _;\n  }\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor (\n    address _master,\n    address _priceOracle,\n    address _swapOperator,\n    address _nxmTokenAddress,\n    address _previousPool\n  ) {\n    master = INXMMaster(_master);\n    nxmToken = INXMToken(_nxmTokenAddress);\n    swapOperator = _swapOperator;\n\n    ILegacyPool previousPool = ILegacyPool(_previousPool);\n\n    // copy over assets and swap details\n    ILegacyPool.Asset[] memory previousAssets = previousPool.getAssets();\n\n    for (uint i = 0; i < previousAssets.length; i++) {\n\n      address assetAddress = previousAssets[i].assetAddress;\n\n      assets.push(\n        Asset(\n          previousAssets[i].assetAddress,\n          previousAssets[i].isCoverAsset,\n          previousAssets[i].isAbandoned\n        )\n      );\n\n      if (assetAddress != ETH) {\n        ILegacyPool.SwapDetails memory previousSwapDetails = previousPool.getAssetSwapDetails(assetAddress);\n        swapDetails[assetAddress] = SwapDetails(\n          previousSwapDetails.minAmount,\n          previousSwapDetails.maxAmount,\n          previousSwapDetails.lastSwapTime,\n          previousSwapDetails.maxSlippageRatio\n        );\n      }\n    }\n\n    _setPriceFeedOracle(IPriceFeedOracle(_priceOracle));\n  }\n\n  receive() external payable {}\n\n  /* ========== ASSET RELATED VIEW FUNCTIONS ========== */\n\n  function getAssetValueInEth(address assetAddress, uint assetAmountInSwapOperator) internal view returns (uint) {\n\n    uint assetBalance = assetAmountInSwapOperator;\n\n    if (assetAddress.code.length != 0) {\n      try IERC20(assetAddress).balanceOf(address(this)) returns (uint balance) {\n        assetBalance += balance;\n      } catch {\n        // If balanceOf reverts consider it 0\n      }\n    }\n\n    // If the assetBalance is 0 skip the oracle call to save gas\n    if (assetBalance == 0) {\n      return 0;\n    }\n\n    return priceFeedOracle.getEthForAsset(assetAddress, assetBalance);\n  }\n\n  ///\n  /// @dev Calculates total value of all pool assets in ether\n  ///\n  function getPoolValueInEth() public override view returns (uint) {\n\n    uint total = address(this).balance;\n\n    uint assetCount = assets.length;\n    uint _assetsInSwapOperatorBitmap = assetsInSwapOperatorBitmap;\n\n    for (uint i = 0; i < assetCount; i++) {\n      Asset memory asset = assets[i];\n\n      if (asset.isAbandoned) {\n        continue;\n      }\n\n      uint assetAmountInSwapOperator = isAssetInSwapOperator(i, _assetsInSwapOperatorBitmap)\n        ? assetInSwapOperator\n        : 0;\n\n      // check if the asset is ETH and skip the oracle call\n      if (i == 0) {\n        total += assetAmountInSwapOperator;\n        continue;\n      }\n\n      total += getAssetValueInEth(asset.assetAddress, assetAmountInSwapOperator);\n    }\n\n    return total;\n  }\n\n  function getAsset(uint assetId) external override view returns (Asset memory) {\n    require(assetId < assets.length, \"Pool: Invalid asset id\");\n    return assets[assetId];\n  }\n\n  function getAssets() external override view returns (Asset[] memory) {\n    return assets;\n  }\n\n  function getAssetSwapDetails(address assetAddress) external view returns (SwapDetails memory) {\n    return swapDetails[assetAddress];\n  }\n\n  function getAssetId(address assetAddress) public view returns (uint) {\n\n    uint assetCount = assets.length;\n    for (uint i = 0; i < assetCount; i++) {\n      if (assets[i].assetAddress == assetAddress) {\n        return i;\n      }\n    }\n\n    revert AssetNotFound();\n  }\n\n  function isAssetInSwapOperator(uint _assetId, uint _assetsInSwapOperatorBitmap) internal pure returns (bool) {\n\n    if (\n      // there are assets in the swap operator\n      _assetsInSwapOperatorBitmap != 0 &&\n      // asset id is not in the swap operator assets\n      ((1 << _assetId) & _assetsInSwapOperatorBitmap == 0)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /* ========== ASSET RELATED MUTATIVE FUNCTIONS ========== */\n\n  function addAsset(\n    address assetAddress,\n    bool isCoverAsset,\n    uint _min,\n    uint _max,\n    uint _maxSlippageRatio\n  ) external onlyGovernance {\n\n    require(assetAddress != address(0), \"Pool: Asset is zero address\");\n    require(_max >= _min, \"Pool: max < min\");\n    require(_maxSlippageRatio <= MAX_SLIPPAGE_DENOMINATOR, \"Pool: Max slippage ratio > 1\");\n\n    (Aggregator aggregator,) = priceFeedOracle.assets(assetAddress);\n    require(address(aggregator) != address(0), \"Pool: PriceFeedOracle lacks aggregator for asset\");\n\n    // Check whether the new asset already exists as a cover asset\n    uint assetCount = assets.length;\n\n    for (uint i = 0; i < assetCount; i++) {\n      require(assetAddress != assets[i].assetAddress, \"Pool: Asset exists\");\n    }\n\n    assets.push(\n      Asset(\n        assetAddress,\n        isCoverAsset,\n        false  // is abandoned\n      )\n    );\n\n    // Set the swap details\n    swapDetails[assetAddress] = SwapDetails(\n      _min.toUint104(),\n      _max.toUint104(),\n      0, // last swap time\n      _maxSlippageRatio.toUint16()\n    );\n  }\n\n  function setAssetDetails(\n    uint assetId,\n    bool isCoverAsset,\n    bool isAbandoned\n  ) external onlyGovernance {\n    require(assets.length > assetId, \"Pool: Asset does not exist\");\n    assets[assetId].isCoverAsset = isCoverAsset;\n    assets[assetId].isAbandoned = isAbandoned;\n  }\n\n  function setSwapDetails(\n    address assetAddress,\n    uint _min,\n    uint _max,\n    uint _maxSlippageRatio\n  ) external onlyGovernance {\n\n    require(_min <= _max, \"Pool: min > max\");\n    require(_maxSlippageRatio <= MAX_SLIPPAGE_DENOMINATOR, \"Pool: Max slippage ratio > 1\");\n\n    uint assetCount = assets.length;\n\n    for (uint i = 0; i < assetCount; i++) {\n\n      if (assetAddress != assets[i].assetAddress) {\n        continue;\n      }\n\n      swapDetails[assetAddress].minAmount = _min.toUint104();\n      swapDetails[assetAddress].maxAmount = _max.toUint104();\n      swapDetails[assetAddress].maxSlippageRatio = _maxSlippageRatio.toUint16();\n\n      return;\n    }\n\n    revert AssetNotFound();\n  }\n\n  function transferAsset(\n    address assetAddress,\n    address payable destination,\n    uint amount\n  ) external onlyGovernance nonReentrant {\n\n    require(swapDetails[assetAddress].maxAmount == 0, \"Pool: Max not zero\");\n    require(destination != address(0), \"Pool: Dest zero\");\n\n    IERC20 token = IERC20(assetAddress);\n    uint balance = token.balanceOf(address(this));\n    uint transferableAmount = amount > balance ? balance : amount;\n\n    token.safeTransfer(destination, transferableAmount);\n  }\n\n  /* ========== SWAPOPERATOR RELATED MUTATIVE FUNCTIONS ========== */\n\n  function transferAssetToSwapOperator(\n    address assetAddress,\n    uint amount\n  ) public override onlySwapOperator nonReentrant whenNotPaused {\n\n    if (assetAddress == ETH) {\n      (bool ok, /* data */) = swapOperator.call{value: amount}(\"\");\n      require(ok, \"Pool: ETH transfer failed\");\n      return;\n    }\n\n    IERC20 token = IERC20(assetAddress);\n    token.safeTransfer(swapOperator, amount);\n  }\n\n  function setSwapDetailsLastSwapTime(\n    address assetAddress,\n    uint32 lastSwapTime\n  ) public override onlySwapOperator whenNotPaused {\n    swapDetails[assetAddress].lastSwapTime = lastSwapTime;\n  }\n\n  function setSwapAssetAmount(address assetAddress, uint value) external onlySwapOperator whenNotPaused {\n\n    uint assetId = getAssetId(assetAddress);\n    assetInSwapOperator = value;\n\n    if (value > 0) {\n      if (assetsInSwapOperatorBitmap != 0) {\n        revert OrderInProgress();\n      }\n\n      assetsInSwapOperatorBitmap = uint32(1 << assetId);\n    } else {\n      assetsInSwapOperatorBitmap = 0;\n    }\n  }\n\n  /* ========== CLAIMS RELATED MUTATIVE FUNCTIONS ========== */\n\n  /// @dev Executes a payout\n  /// @param assetId        Index of the cover asset\n  /// @param payoutAddress  Send funds to this address\n  /// @param amount         Amount to send\n  /// @param ethDepositAmount  Deposit amount to send\n  ///\n  function sendPayout(\n    uint assetId,\n    address payable payoutAddress,\n    uint amount,\n    uint ethDepositAmount\n  ) external override onlyInternal nonReentrant {\n\n    Asset memory asset = assets[assetId];\n\n    if (asset.assetAddress == ETH) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool transferSucceeded, /* data */) = payoutAddress.call{value: amount}(\"\");\n      require(transferSucceeded, \"Pool: ETH transfer failed\");\n    } else {\n      IERC20(asset.assetAddress).safeTransfer(payoutAddress, amount);\n    }\n\n    if (ethDepositAmount > 0) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool transferSucceeded, /* data */) = payoutAddress.call{value: ethDepositAmount}(\"\");\n      require(transferSucceeded, \"Pool: ETH transfer failed\");\n      emit DepositReturned(payoutAddress, ethDepositAmount);\n    }\n\n    emit Payout(payoutAddress, asset.assetAddress, amount);\n\n    mcr().updateMCRInternal(true);\n  }\n\n  /* ========== TOKEN RELATED MUTATIVE FUNCTIONS ========== */\n\n  /// @dev Sends ETH to a member in exchange for NXM tokens.\n  /// @param member  Member address\n  /// @param amount  Amount of ETH to send\n  ///\n  function sendEth(address member, uint amount) external override onlyRamm nonReentrant {\n    (bool transferSucceeded, /* data */) = member.call{value: amount}(\"\");\n    require(transferSucceeded, \"Pool: ETH transfer failed\");\n  }\n\n  function calculateMCRRatio(\n    uint totalAssetValue,\n    uint mcrEth\n  ) public override pure returns (uint) {\n    return totalAssetValue * (10 ** MCR_RATIO_DECIMALS) / mcrEth;\n  }\n\n  /* ========== TOKEN RELATED VIEW FUNCTIONS ========== */\n\n  /// Uses internal price for calculating the token price in ETH\n  /// It's being used in Cover and IndividualClaims\n  /// Returns the internal NXM price in a given asset.\n  ///\n  /// @dev The pool contract is not a proxy and its address will change as we upgrade it.\n  /// @dev You may want TokenController.getTokenPrice() for a stable address since it's a proxy.\n  ///\n  /// @param assetId  Index of the cover asset.\n  ///\n  function getInternalTokenPriceInAsset(uint assetId) public view override returns (uint tokenPrice) {\n\n    require(assetId < assets.length, \"Pool: Unknown cover asset\");\n    address assetAddress = assets[assetId].assetAddress;\n\n    uint tokenInternalPrice = ramm().getInternalPrice();\n\n    return priceFeedOracle.getAssetForEth(assetAddress, tokenInternalPrice);\n  }\n\n  /// Uses internal price for calculating the token price in ETH and updates TWAP\n  /// It's being used in Cover\n  /// Returns the internal NXM price in a given asset.\n  ///\n  /// @dev The pool contract is not a proxy and its address will change as we upgrade it.\n  /// @dev You may want TokenController.getTokenPrice() for a stable address since it's a proxy.\n  ///\n  /// @param assetId  Index of the cover asset.\n  ///\n  function getInternalTokenPriceInAssetAndUpdateTwap(uint assetId) public override returns (uint tokenPrice) {\n\n    require(assetId < assets.length, \"Pool: Unknown cover asset\");\n    address assetAddress = assets[assetId].assetAddress;\n\n    uint tokenInternalPrice = ramm().getInternalPriceAndUpdateTwap();\n\n    return priceFeedOracle.getAssetForEth(assetAddress, tokenInternalPrice);\n  }\n\n  /// [deprecated] Returns spot NXM price in ETH from ramm contract.\n  ///\n  /// @dev The pool contract is not a proxy and its address will change as we upgrade it.\n  /// @dev You may want TokenController.getTokenPrice() for a stable address since it's a proxy.\n  ///\n  function getTokenPrice() public override view returns (uint tokenPrice) {\n    (, tokenPrice) = ramm().getSpotPrices();\n    return tokenPrice;\n  }\n\n  function getMCRRatio() public override view returns (uint) {\n    uint totalAssetValue = getPoolValueInEth();\n    uint mcrEth = mcr().getMCR();\n    return calculateMCRRatio(totalAssetValue, mcrEth);\n  }\n\n  /* ========== POOL UPGRADE RELATED MUTATIVE FUNCTIONS ========== */\n\n  // Revert if any of the asset functions revert while not being marked for getting abandoned.\n  // Otherwise, continue without reverting while the marked asset will remain stuck in the\n  // previous pool contract.\n  function upgradeCapitalPool(address payable newPoolAddress) external override onlyMaster nonReentrant {\n\n    // transfer ETH\n    (bool ok, /* data */) = newPoolAddress.call{value: address(this).balance}(\"\");\n    require(ok, \"Pool: Transfer failed\");\n\n    uint assetCount = assets.length;\n\n    // start from 1 (0 is ETH)\n    for (uint i = 1; i < assetCount; i++) {\n\n      if (assets[i].isAbandoned) {\n        continue;\n      }\n\n      IERC20 asset = IERC20(assets[i].assetAddress);\n      uint balance = asset.balanceOf(address(this));\n      asset.safeTransfer(newPoolAddress, balance);\n    }\n  }\n\n  function _setPriceFeedOracle(IPriceFeedOracle _priceFeedOracle) internal {\n    uint assetCount = assets.length;\n\n    // start from 1 (0 is ETH and doesn't need an oracle)\n    for (uint i = 1; i < assetCount; i++) {\n      (Aggregator aggregator,) = _priceFeedOracle.assets(assets[i].assetAddress);\n      require(address(aggregator) != address(0), \"Pool: PriceFeedOracle lacks aggregator for asset\");\n    }\n\n    priceFeedOracle = _priceFeedOracle;\n  }\n\n  function updateUintParameters(bytes8 /* code */, uint /* value */) external view onlyGovernance {\n    revert UnknownParameter();\n  }\n\n  function updateAddressParameters(bytes8 code, address value) external onlyGovernance {\n\n    if (code == \"SWP_OP\") {\n      if (swapOperator != address(0)) {\n        require(!ISwapOperator(swapOperator).orderInProgress(), 'Pool: Cancel all swaps before changing swapOperator');\n      }\n      swapOperator = value;\n      return;\n    }\n\n    if (code == \"PRC_FEED\") {\n      _setPriceFeedOracle(IPriceFeedOracle(value));\n      return;\n    }\n\n    revert UnknownParameter();\n  }\n\n  /* ========== DEPENDENCIES ========== */\n\n  function mcr() internal view returns (IMCR) {\n    return IMCR(internalContracts[uint(ID.MC)]);\n  }\n\n  function ramm() internal view returns (IRamm) {\n    return IRamm(internalContracts[uint(ID.RA)]);\n  }\n\n  /**\n   * @dev Update dependent contract address\n   * @dev Implements MasterAware interface function\n   */\n  function changeDependentContractAddress() public {\n    internalContracts[uint(ID.MC)] = master.getLatestAddress(\"MC\");\n    internalContracts[uint(ID.RA)] = master.getLatestAddress(\"RA\");\n    // needed for onlyMember modifier\n    internalContracts[uint(ID.MR)] = master.getLatestAddress(\"MR\");\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}